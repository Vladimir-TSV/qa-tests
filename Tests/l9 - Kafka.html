<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>KAFKA</title>
<link rel="stylesheet" href="styles.css">
<script src="script.js" defer></script>

</head>
<body>
<div class="fixed-top" id="fixedTop">
    <button class="check-btn" onclick="checkAnswers()" style="display: none;">Проверить</button>
    <button class="reset-btn" onclick="resetTest()" style="display: none;">Начать заново</button>
    <a href="../index.html" class="return-button">Вернуться на главную</a>
</div>

<div id="startContainer">
    <h1>KAFKA</h1>
    <button class="start-btn" onclick="startTest()">Начать тест</button>
</div>

<div id="testContainer">
</div>

<div id="results">
    <h3>Результаты:</h3>
    <ul id="resultList"></ul>
</div>

<script>
const questions = [
{
      "question": "Что такое Apache Kafka?",
      "answers": [
        "Реляционная база данных",
        "Система управления контентом",
        "Распределенная потоковая платформа",
        "Сервис электронной почты"
      ],
      "correct": ["Распределенная потоковая платформа"],
      "comment": "Kafka - распределенная система обмена сообщениями pub/sub с высокой пропускной способностью"
    },
    {
      "question": "Какие основные компоненты Kafka?",
      "answers": [
        "Брокеры, продюсеры, консьюмеры",
        "Серверы, клиенты, роутеры",
        "Ноды, кластеры, шарды",
        "Таблицы, индексы, представления"
      ],
      "correct": ["Брокеры, продюсеры, консьюмеры"],
      "comment": "Основная триада: брокеры (серверы), продюсеры (отправители), консьюмеры (получатели)"
    },
    {
      "question": "Что такое 'топик' в Kafka?",
      "answers": [
        "Категория или имя потока сообщений",
        "Тип сообщения",
        "Сервер Kafka",
        "Группа консьюмеров"
      ],
      "correct": ["Категория или имя потока сообщений"],
      "comment": "Топик - это категория/канал, в который публикуются сообщения"
    },
    {
      "question": "Как Kafka обеспечивает отказоустойчивость?",
      "answers": [
        "Репликацией партиций",
        "Созданием резервных брокеров",
        "Шифрованием сообщений",
        "Все варианты верны"
      ],
      "correct": ["Репликацией партиций"],
      "comment": "Каждая партиция реплицируется на несколько брокеров (replication factor)"
    },
    {
      "question": "Что такое 'партиция' в Kafka?",
      "answers": [
        "Резервная копия топика",
        "Часть топика для параллельной обработки",
        "Тип сообщения",
        "Группа брокеров"
      ],
      "correct": ["Часть топика для параллельной обработки"],
      "comment": "Партиции позволяют параллелить обработку сообщений в топике"
    },
    {
      "question": "Какой минимальный набор конфигураций для продюсера Kafka?",
      "answers": [
        "bootstrap.servers, key.serializer, value.serializer",
        "server.ip, topic.name, message.type",
        "zookeeper.connect, group.id, offset",
        "Все варианты неверны"
      ],
      "correct": ["bootstrap.servers, key.serializer, value.serializer"],
      "comment": "Минимально нужно указать серверы, сериализаторы ключа и значения"
    },
    {
      "question": "Как консьюмеры Kafka отслеживают свою позицию?",
      "answers": [
        "Через механизм оффсетов",
        "По временным меткам",
        "Через порядковый номер сообщения",
        "По хешу сообщения"
      ],
      "correct": ["Через механизм оффсетов"],
      "comment": "Оффсет - уникальный ID сообщения в партиции, который запоминает консьюмер"
    },
    {
      "question": "Для чего используется ZooKeeper в Kafka?",
      "answers": [
        "Хранение сообщений",
        "Координация кластера и метаданные",
        "Сериализация данных",
        "Маршрутизация сообщений"
      ],
      "correct": ["Координация кластера и метаданные"],
      "comment": "ZooKeeper хранит метаданные кластера, контроллера, ACL и т.д. (в новых версиях заменяется на KRaft)"
    },
    {
      "question": "Что такое Consumer Group?",
      "answers": [
        "Группа топиков",
        "Набор брокеров",
        "Группа консьюмеров, совместно обрабатывающих сообщения",
        "Тип сообщения"
      ],
      "correct": ["Группа консьюмеров, совместно обрабатывающих сообщения"],
      "comment": "Консьюмеры в группе делят между собой партиции топика"
    },
    {
      "question": "Как Kafka обеспечивает сохранность сообщений?",
      "answers": [
        "Хранит сообщения в памяти",
        "Сохраняет на диск с конфигурируемым сроком хранения",
        "Отправляет подтверждения получателям",
        "Все варианты верны"
      ],
      "correct": ["Сохраняет на диск с конфигурируемым сроком хранения"],
      "comment": "Сообщения сохраняются на диск и хранятся в течение retention.ms или retention.bytes"
    },
    {
      "question": "Какой интерфейс использует Kafka для передачи данных?",
      "answers": [
        "REST API",
        "Собственный бинарный протокол",
        "WebSockets",
        "gRPC"
      ],
      "correct": ["Собственный бинарный протокол"],
      "comment": "Kafka использует оптимизированный бинарный протокол поверх TCP"
    },
    {
      "question": "Что такое ISR в Kafka?",
      "answers": [
        "Тип сообщения",
        "Список синхронизированных реплик",
        "Формат сериализации",
        "Протокол безопасности"
      ],
      "correct": ["Список синхронизированных реплик"],
      "comment": "In-Sync Replicas - реплики, которые успешно синхронизируются с лидером"
    },
    {
      "question": "Как можно удалить сообщения из Kafka?",
      "answers": [
        "Командой DELETE",
        "Автоматически по истечении срока хранения",
        "Вручную через администраторский API",
        "Варианты 2 и 3 верны"
      ],
      "correct": ["Варианты 2 и 3 верны"],
      "comment": "Сообщения удаляются по истечении retention времени или через API (для топиков compacted)"
    },
    {
      "question": "Что такое 'compacted topic'?",
      "answers": [
        "Топик с сжатыми сообщениями",
        "Топик с удаленными дубликатами по ключу",
        "Топик с уменьшенным размером партиций",
        "Топик с ограниченным retention"
      ],
      "correct": ["Топик с удаленными дубликатами по ключу"],
      "comment": "Compacted топик сохраняет только последнее сообщение для каждого ключа"
    },
    {
      "question": "Какой гарантии доставки НЕТ в Kafka?",
      "answers": [
        "At most once",
        "At least once",
        "Exactly once",
        "Exactly twice"
      ],
      "correct": ["Exactly twice"],
      "comment": "Kafka поддерживает три режима: 0 (at most once), 1 (at least once), -1 (exactly once)"
    },
    {
      "question": "Как работает Exactly Once Semantics (EOS) в Kafka?",
      "answers": [
        "Через идемпотентного продюсера и транзакции",
        "Дублированием сообщений",
        "Подтверждением от всех консьюмеров",
        "Все варианты неверны"
      ],
      "correct": ["Через идемпотентного продюсера и транзакции"],
      "comment": "EOS достигается комбинацией идемпотентности и транзакций между продюсерами/консьюмерами"
    },
    {
      "question": "Что такое Kafka Connect?",
      "answers": [
        "Фреймворк для потоковой обработки",
        "Инструмент для подключения внешних систем",
        "Протокол безопасности",
        "Тип сообщения"
      ],
      "correct": ["Инструмент для подключения внешних систем"],
      "comment": "Kafka Connect - фреймворк для интеграции с БД, хранилищами и другими системами"
    },
    {
      "question": "Для чего используется Kafka Streams?",
      "answers": [
        "Для потоковой обработки данных",
        "Для хранения сообщений",
        "Для мониторинга кластера",
        "Для балансировки нагрузки"
      ],
      "correct": ["Для потоковой обработки данных"],
      "comment": "Kafka Streams - библиотека для построения потоковых приложений поверх Kafka"
    },
    {
      "question": "Какой инструмент мониторинга Kafka вы бы использовали?",
      "answers": [
        "Kafka Manager",
        "Prometheus + Grafana",
        "Confluent Control Center",
        "Любой из перечисленных"
      ],
      "correct": ["Любой из перечисленных"],
      "comment": "Все варианты подходят для мониторинга Kafka с разными возможностями"
    },
    {
      "question": "Как тестировать Kafka-приложения?",
      "answers": [
        "Тестировать изолированно с EmbeddedKafka",
        "Использовать тестовый кластер",
        "Мокировать Kafka клиенты",
        "Все варианты верны"
      ],
      "correct": ["Все варианты верны"],
      "comment": "В зависимости от контекста можно использовать разные подходы к тестированию"
    },
    {
      "question": "Что проверять при тестировании Kafka?",
      "answers": [
        "Доставку сообщений (гарантии)",
        "Обработку дублей",
        "Производительность и латенси",
        "Все варианты верны"
      ],
      "correct": ["Все варианты верны"],
      "comment": "Важно проверять все аспекты: функциональность, надежность, производительность"
    },
    {
      "question": "Как имитировать проблему потери брокера при тестировании?",
      "answers": [
        "Остановить брокер вручную",
        "Использовать Chaos Engineering инструменты",
        "Настроить автоматический failover",
        "Варианты 1 и 2 верны"
      ],
      "correct": ["Варианты 1 и 2 верны"],
      "comment": "Ручная остановка или инструменты вроде Chaos Monkey помогают тестировать отказоустойчивость"
    },
    {
      "question": "Как проверить обработку дубликатов в консьюмере?",
      "answers": [
        "Отправить одинаковые сообщения дважды",
        "Использовать идемпотентный продюсер",
        "Сбросить оффсеты консьюмера",
        "Все варианты верны"
      ],
      "correct": ["Все варианты верны"],
      "comment": "Все методы помогают проверить обработку дублей в разных сценариях"
    }
];

</script>
</body>
</html>
