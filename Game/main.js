// Общие переменные
let playerName = '';
let score = 0;
let errors = 0;
const maxErrors = 10; // Максимальное количество ошибок

// Вопросы для викторины
const questions = [{
    question: "Что такое Name (Имя)?",
    answers: ["Имя куки", "Значение куки", "Дата и время когда куки станет недействительным", "Время жизни куки в секундах", "Домен, для которого куки действителен", "Путь на сервер, для которого куки действителен", "Куки будет отправляться только по защищенному HTTPS-соединению", "Куки не доступны через клиентский javascript, для повышения безопасности", "Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"],
    correct: ["Имя куки"]
},
{
    question: "Что такое Value (Значение)?",
    answers: ["Имя куки", "Значение куки", "Дата и время когда куки станет недействительным", "Время жизни куки в секундах", "Домен, для которого куки действителен", "Путь на сервер, для которого куки действителен", "Куки будет отправляться только по защищенному HTTPS-соединению", "Куки не доступны через клиентский javascript, для повышения безопасности", "Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"],
    correct: ["Значение куки"]
},
{
    question: "Что такое Expires (истекает)?",
    answers: ["Имя куки", "Значение куки", "Дата и время когда куки станет недействительным", "Время жизни куки в секундах", "Домен, для которого куки действителен", "Путь на сервер, для которого куки действителен", "Куки будет отправляться только по защищенному HTTPS-соединению", "Куки не доступны через клиентский javascript, для повышения безопасности", "Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"],
    correct: ["Дата и время когда куки станет недействительным"]
},
{
    question: "Что такое Max-Age (Максимальный возраст)?",
    answers: ["Имя куки", "Значение куки", "Дата и время когда куки станет недействительным", "Время жизни куки в секундах", "Домен, для которого куки действителен", "Путь на сервер, для которого куки действителен", "Куки будет отправляться только по защищенному HTTPS-соединению", "Куки не доступны через клиентский javascript, для повышения безопасности", "Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"],
    correct: ["Время жизни куки в секундах"]
},
{
    question: "Что такое Domain (Домен)?",
    answers: ["Имя куки", "Значение куки", "Дата и время когда куки станет недействительным", "Время жизни куки в секундах", "Домен, для которого куки действителен", "Путь на сервер, для которого куки действителен", "Куки будет отправляться только по защищенному HTTPS-соединению", "Куки не доступны через клиентский javascript, для повышения безопасности", "Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"],
    correct: ["Домен, для которого куки действителен"]
},
{
    question: "Что такое Path (Путь)?",
    answers: ["Имя куки", "Значение куки", "Дата и время когда куки станет недействительным", "Время жизни куки в секундах", "Домен, для которого куки действителен", "Путь на сервер, для которого куки действителен", "Куки будет отправляться только по защищенному HTTPS-соединению", "Куки не доступны через клиентский javascript, для повышения безопасности", "Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"],
    correct: ["Путь на сервер, для которого куки действителен"]
},
{
    question: "Что такое Secure (Безопасный)?",
    answers: ["Имя куки", "Значение куки", "Дата и время когда куки станет недействительным", "Время жизни куки в секундах", "Домен, для которого куки действителен", "Путь на сервер, для которого куки действителен", "Куки будет отправляться только по защищенному HTTPS-соединению", "Куки не доступны через клиентский javascript, для повышения безопасности", "Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"],
    correct: ["Куки будет отправляться только по защищенному HTTPS-соединению"]
},
{
    question: "Что такое HttpOnly?",
    answers: ["Имя куки", "Значение куки", "Дата и время когда куки станет недействительным", "Время жизни куки в секундах", "Домен, для которого куки действителен", "Путь на сервер, для которого куки действителен", "Куки будет отправляться только по защищенному HTTPS-соединению", "Куки не доступны через клиентский javascript, для повышения безопасности", "Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"],
    correct: ["Куки не доступны через клиентский javascript, для повышения безопасности"]
},
{
    question: "Что такое SameSite?",
    answers: ["Имя куки", "Значение куки", "Дата и время когда куки станет недействительным", "Время жизни куки в секундах", "Домен, для которого куки действителен", "Путь на сервер, для которого куки действителен", "Куки будет отправляться только по защищенному HTTPS-соединению", "Куки не доступны через клиентский javascript, для повышения безопасности", "Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"],
    correct: ["Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None"]
},
{
    question: "Какой атрибут куки отвечает за 'Имя куки'?",
    answers: ["Name", "Value", "Expires", "Max-Age", "Domain", "Path", "Secure", "HttpOnly", "SameSite"],
    correct: ["Name"]
},
{
    question: "Какой атрибут куки отвечает за 'Значение куки'?",
    answers: ["Name", "Value", "Expires", "Max-Age", "Domain", "Path", "Secure", "HttpOnly", "SameSite"],
    correct: ["Value"]
},
{
    question: "Какой атрибут куки отвечает за 'Дата и время когда куки станет недействительным'?",
    answers: ["Name", "Value", "Expires", "Max-Age", "Domain", "Path", "Secure", "HttpOnly", "SameSite"],
    correct: ["Expires"]
},
{
    question: "Какой атрибут куки отвечает за 'Время жизни куки в секундах'?",
    answers: ["Name", "Value", "Expires", "Max-Age", "Domain", "Path", "Secure", "HttpOnly", "SameSite"],
    correct: ["Max-Age"]
},
{
    question: "Какой атрибут куки отвечает за 'Домен, для которого куки действителен'?",
    answers: ["Name", "Value", "Expires", "Max-Age", "Domain", "Path", "Secure", "HttpOnly", "SameSite"],
    correct: ["Domain"]
},
{
    question: "Какой атрибут куки отвечает за 'Путь на сервер, для которого куки действителен'?",
    answers: ["Name", "Value", "Expires", "Max-Age", "Domain", "Path", "Secure", "HttpOnly", "SameSite"],
    correct: ["Path"]
},
{
    question: "Какой атрибут куки отвечает за 'Куки будет отправляться только по защищенному HTTPS-соединению'?",
    answers: ["Name", "Value", "Expires", "Max-Age", "Domain", "Path", "Secure", "HttpOnly", "SameSite"],
    correct: ["Secure"]
},
{
    question: "Какой атрибут куки отвечает за 'Куки не доступны через клиентский javascript, для повышения безопасности'?",
    answers: ["Name", "Value", "Expires", "Max-Age", "Domain", "Path", "Secure", "HttpOnly", "SameSite"],
    correct: ["HttpOnly"]
},
{
    question: "Какой атрибут куки отвечает за 'Контролирует, отправляются ли куки при запросах между сайтами. Может принимать значения Strict, Lax или None'?",
    answers: ["Name", "Value", "Expires", "Max-Age", "Domain", "Path", "Secure", "HttpOnly", "SameSite"],
    correct: ["SameSite"]
},
{
    question: "Что такое тестирование?",
    answers: ["Поиск разницы между ожидаемым и фактическим результатом", "Процесс написания кода", "Процесс разработки новых функций", "Процесс документирования кода", "Процесс обучения пользователей"],
    correct: ["Поиск разницы между ожидаемым и фактическим результатом"]
},
{
    question: "В чем цель тестирования? (Выберите все подходящие варианты)",
    answers: ["Предоставление актуальной информации о состоянии продукта", "Обнаружение в продукте багов", "Написание документации", "Обучение пользователей", "Улучшение дизайна продукта"],
    correct: ["Предоставление актуальной информации о состоянии продукта", "Обнаружение в продукте багов"]
},
{
    question: "Что такое QA?",
    answers: ["Обеспечение качества продукта", "Контроль качества продукта", "Процесс разработки продукта", "Процесс документирования продукта", "Процесс обучения пользователей"],
    correct: ["Обеспечение качества продукта"]
},
{
    question: "Что такое QC?",
    answers: ["Контроль качества продукта", "Обеспечение качества продукта", "Процесс разработки продукта", "Процесс документирования продукта", "Процесс обучения пользователей"],
    correct: ["Контроль качества продукта"]
},
{
    question: "Что такое HTTPS?",
    answers: ["Протокол передачи данных с шифрованием", "Язык программирования", "База данных", "Тип клиент-серверной архитектуры", "Вид тестирования"],
    correct: ["Протокол передачи данных с шифрованием"]
},
{
    question: "Что такое Java?",
    answers: ["Язык программирования для бэкенда", "Язык программирования для фронтенда", "Протокол передачи данных", "База данных", "Вид тестирования"],
    correct: ["Язык программирования для бэкенда"]
},
{
    question: "Что такое JavaScript?",
    answers: ["Язык программирования для фронтенда", "Язык программирования для бэкенда", "Протокол передачи данных", "База данных", "Вид тестирования"],
    correct: ["Язык программирования для фронтенда"]
},
{
    question: "Что такое Авторизация?",
    answers: ["Проверка прав доступа", "Проверка пароля", "Узнавание пользователя по логину", "Проверка на правила заполнения полей", "Процесс шифрования данных"],
    correct: ["Проверка прав доступа"]
},
{
    question: "Что такое Аутентификация?",
    answers: ["Общий процесс проверки подлинности, который включает в себя идентификацию и верификацию", "Проверка прав доступа", "Проверка пароля", "Узнавание пользователя по логину", "Проверка на правила заполнения полей", "Процесс шифрования данных"],
    correct: ["Общий процесс проверки подлинности, который включает в себя идентификацию и верификацию"]
},
{
    question: "Что такое Идентификация?",
    answers: ["Узнавание пользователя по логину, часть аутентификации", "Проверка пароля", "Проверка прав доступа", "Проверка на правила заполнения полей", "Процесс шифрования данных"],
    correct: ["Узнавание пользователя по логину, часть аутентификации"]
},
{
    question: "Что такое Валидация?",
    answers: ["Проверка на правила заполнения полей", "Проверка пароля", "Проверка прав доступа", "Узнавание пользователя по логину", "Процесс шифрования данных"],
    correct: ["Проверка на правила заполнения полей"]
},
{
    question: "Что такое Толстый клиент?",
    answers: ["Клиент, выполняющий большую часть логики на своей стороне", "Клиент, выполняющий основную логику на сервере", "Клиент, который не использует сервер", "Клиент, который не использует базу данных", "Клиент, который не использует HTTP"],
    correct: ["Клиент, выполняющий большую часть логики на своей стороне"]
},
{
    question: "Что такое Тонкий клиент?",
    answers: ["Клиент, выполняющий основную логику на сервере", "Клиент, выполняющий большую часть логики на своей стороне", "Клиент, который не использует сервер", "Клиент, который не использует базу данных", "Клиент, который не использует HTTP"],
    correct: ["Клиент, выполняющий основную логику на сервере"]
},
{
    question: "Какие уровни клиент-серверной архитектуры вы знаете? (Выберите все подходящие варианты)",
    answers: ["Клиент", "Бэкенд", "База данных", "Прокси-сервер", "Кэш"],
    correct: ["Клиент", "Бэкенд", "База данных"]
},
{
    question: "Из каких частей состоит HTTP/HTTPS запрос? (Выберите все подходящие варианты)",
    answers: ["URL", "Headers", "Body", "Cookies", "Метод (GET, POST и т.д.)"],
    correct: ["URL", "Headers", "Body", "Метод (GET, POST и т.д.)"]
},
  {
    question: "В чем разница между QA и QC?",
    answers: ["QC — это проверка качества, а QA — обеспечение качества", "QA и QC — это одно и то же", "QC включает в себя QA", "QA — это процесс разработки, а QC — тестирование", "QA и QC не связаны с качеством продукта"],
    correct: ["QC — это проверка качества, а QA — обеспечение качества"]
},
{
    question: "Что такое клиент и бэкенд?",
    answers: ["Клиент — это часть продукта, с которой взаимодействует пользователь, а бэкенд — внутренняя часть, отвечающая за логику", "Клиент и бэкенд — это одно и то же", "Бэкенд — это часть продукта, с которой взаимодействует пользователь", "Клиент — это сервер, а бэкенд — база данных", "Клиент и бэкенд не связаны с цифровыми продуктами"],
    correct: ["Клиент — это часть продукта, с которой взаимодействует пользователь, а бэкенд — внутренняя часть, отвечающая за логику"]
},
{
    question: "Что такое HTTP?",
    answers: ["Протокол передачи данных", "Язык программирования", "База данных", "Тип шифрования", "Вид клиент-серверной архитектуры"],
    correct: ["Протокол передачи данных"]
},
{
    question: "В чем разница между HTTP и HTTPS?",
    answers: ["HTTPS использует шифрование", "HTTP быстрее, чем HTTPS", "HTTPS не поддерживает cookies", "HTTP и HTTPS — это одно и то же", "HTTPS не используется в современных приложениях"],
    correct: ["HTTPS использует шифрование"]
},
{
    question: "Что такое ручка, метод и эндпоинт?",
    answers: ["Это синонимы HTTP запроса", "Это разные понятия, не связанные с HTTP", "Это типы баз данных", "Это виды шифрования", "Это части клиент-серверной архитектуры"],
    correct: ["Это синонимы HTTP запроса"]
},
{
    question: "Что такое Квери?",
    answers: ["Часть URL для передачи дополнительной информации", "Тип HTTP запроса", "Вид шифрования", "Часть базы данных", "Тип клиент-серверной архитектуры"],
    correct: ["Часть URL для передачи дополнительной информации"]
},
{
    question: "Что такое Cookie?",
    answers: ["Данные, которые браузер хранит на своей стороне", "Тип HTTP запроса", "Вид шифрования", "Часть базы данных", "Тип клиент-серверной архитектуры"],
    correct: ["Данные, которые браузер хранит на своей стороне"]
},
{
    question: "Java и JavaScript это одно и то же?",
    answers: ["Нет, это разные языки программирования", "Да, это одно и то же", "Java используется для фронтенда, а JavaScript для бэкенда", "JavaScript — это библиотека для Java", "Java и JavaScript не связаны с программированием"],
    correct: ["Нет, это разные языки программирования"]
},
{
    question: "Что такое клиент-серверная архитектура?",
    answers: ["Архитектура, где продукт делится на клиент, бэкенд и базу данных", "Архитектура, где все данные хранятся на клиенте", "Архитектура, где сервер не используется", "Архитектура, где клиент и сервер — это одно и то же", "Архитектура, где база данных отсутствует"],
    correct: ["Архитектура, где продукт делится на клиент, бэкенд и базу данных"]
},
{
    question: "Какие ты знаешь основные принципы тестирования? (Выберите все подходящие варианты)",
    answers: ["Тестирование демонстрирует наличие дефектов", "Исчерпывающее тестирование недостижимо", "Раннее тестирование сохраняет время и деньги", "Парадокс пестицида", "Тестирование не требует документации"],
    correct: ["Тестирование демонстрирует наличие дефектов", "Исчерпывающее тестирование недостижимо", "Раннее тестирование сохраняет время и деньги", "Парадокс пестицида"]
},
{
    question: "В чем разница между Авторизацией, Аутентификацией, Идентификацией и Валидацией? (Выберите все подходящие варианты)",
    answers: ["Валидация — проверка на правила заполнения полей", "Идентификация — узнавание пользователя по логину", "Аутентификация — проверка пароля", "Авторизация — проверка прав доступа", "Все эти понятия означают одно и то же"],
    correct: ["Валидация — проверка на правила заполнения полей", "Идентификация — узнавание пользователя по логину", "Аутентификация — проверка пароля", "Авторизация — проверка прав доступа"]
},
{
    question: "В чем разница между тонким и толстым клиентом? (Выберите все подходящие варианты)",
    answers: ["Тонкий клиент выполняет основные процессы на сервере", "Толстый клиент выполняет большую часть логики на своей стороне", "Тонкий клиент — это фотошоп", "Толстый клиент — это сайт в браузере", "Тонкий и толстый клиент — это одно и то же"],
    correct: ["Тонкий клиент выполняет основные процессы на сервере", "Толстый клиент выполняет большую часть логики на своей стороне"]
},
{
question: "Что такое Верификация?",
answers: [ "Процесс подтверждения личности пользователя, часть аутентификации", "Проверка подлинности данных или пользователя", "Процесс шифрования данных для защиты", "Проверка на наличие ошибок в коде", "Установка новых обновлений системы"],
correct: ["Процесс подтверждения личности пользователя, часть аутентификации"]
},
{
    question: "Что такое Cookies?",
    answers: [
        "Временное хранилище данных, которое очищается при закрытии браузера.",
        "Небольшие текстовые файлы, которые хранятся на стороне клиента и используются для отслеживания состояния сессии.",
        "Хранилище данных, доступное только во время сессии.",
        "Хранилище данных, которое синхронизируется между устройствами."
    ],
    correct: ["Небольшие текстовые файлы, которые хранятся на стороне клиента и используются для отслеживания состояния сессии."]
},
{
    question: "Для чего используются Cookies?",
    answers: [
        "Для хранения больших объемов данных.",
        "Для отслеживания состояния сессии, хранения пользовательских предпочтений и авторизации.",
        "Для кэширования ресурсов.",
        "Для хранения данных только во время сессии."
    ],
    correct: ["Для отслеживания состояния сессии, хранения пользовательских предпочтений и авторизации."]
},
{
    question: "Что такое сессия?",
    answers: [
        "Постоянное соединение между клиентом и сервером.",
        "Временное соединение между клиентом и сервером, которое длится до закрытия браузера.",
        "Хранилище данных, которое сохраняется после закрытия браузера.",
        "Хранилище данных, доступное только для одного запроса."
    ],
    correct: ["Временное соединение между клиентом и сервером, которое длится до закрытия браузера."]
},
{
    question: "Что такое авторизация?",
    answers: [
        "Процесс проверки подлинности пользователя.",
        "Процесс предоставления доступа к ресурсам на основе ролей пользователя.",
        "Процесс хранения данных пользователя.",
        "Процесс кэширования ресурсов."
    ],
    correct: ["Процесс предоставления доступа к ресурсам на основе ролей пользователя."]
},
{
    question: "Что такое аутентификация?",
    answers: [
        "Процесс проверки подлинности пользователя.",
        "Процесс предоставления доступа к ресурсам на основе ролей пользователя.",
        "Процесс хранения данных пользователя.",
        "Процесс кэширования ресурсов."
    ],
    correct: ["Процесс проверки подлинности пользователя."]
},
{
    question: "Какой HTTP-статус обычно возвращается при успешной авторизации?",
    answers: [
        "200 OK",
        "401 Unauthorized",
        "403 Forbidden",
        "404 Not Found"
    ],
    correct: ["200 OK"]
},
{
    question: "Какой HTTP-статус обычно возвращается при отсутствии авторизации?",
    answers: [
        "200 OK",
        "401 Unauthorized",
        "403 Forbidden",
        "404 Not Found"
    ],
    correct: ["401 Unauthorized"]
},
{
    question: "Какой HTTP-статус обычно возвращается при отсутствии доступа к ресурсу?",
    answers: [
        "200 OK",
        "401 Unauthorized",
        "403 Forbidden",
        "404 Not Found"
    ],
    correct: ["403 Forbidden"]
},
{
    question: "Какой HTTP-метод обычно используется для отправки данных при авторизации?",
    answers: [
        "GET",
        "POST",
        "PUT",
        "DELETE"
    ],
    correct: ["POST"]
},
{
    question: "Какой HTTP-метод обычно используется для выхода из системы (logout)?",
    answers: [
        "GET",
        "POST",
        "PUT",
        "DELETE"
    ],
    correct: ["POST"]
},
{
    question: "Как проверить, что Cookies устанавливаются корректно?",
    answers: [
        "Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'.",
        "Проверить вкладку 'Network' в инструментах разработчика.",
        "Проверить вкладку 'Console' в инструментах разработчика.",
        "Проверить вкладку 'Performance' в инструментах разработчика."
    ],
    correct: ["Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'."]
},
{
    question: "Как проверить, что сессия завершается после закрытия браузера?",
    answers: [
        "Закрыть браузер, открыть его снова и проверить, доступна ли сессия.",
        "Проверить данные в Local Storage.",
        "Проверить данные в Cookies.",
        "Проверить данные в IndexedDB."
    ],
    correct: ["Закрыть браузер, открыть его снова и проверить, доступна ли сессия."]
},
{
    question: "Как проверить, что пользователь авторизован?",
    answers: [
        "Проверить наличие Cookies с данными авторизации.",
        "Проверить данные в Local Storage.",
        "Проверить данные в Session Storage.",
        "Проверить данные в IndexedDB."
    ],
    correct: ["Проверить наличие Cookies с данными авторизации."]
},
{
    question: "Как проверить, что пользователь не имеет доступа к ресурсу?",
    answers: [
        "Проверить HTTP-статус 403 Forbidden.",
        "Проверить HTTP-статус 401 Unauthorized.",
        "Проверить HTTP-статус 404 Not Found.",
        "Проверить HTTP-статус 200 OK."
    ],
    correct: ["Проверить HTTP-статус 403 Forbidden."]
},
{
    question: "Как проверить, что данные авторизации передаются безопасно?",
    answers: [
        "Проверить, что данные передаются по HTTPS.",
        "Проверить, что данные передаются по HTTP.",
        "Проверить, что данные передаются в открытом виде.",
        "Проверить, что данные передаются в Local Storage."
    ],
    correct: ["Проверить, что данные передаются по HTTPS."]
},
{
    question: "Если Cookies не устанавливаются, что вы проверите в первую очередь?",
    answers: [
        "Корректность кода, который устанавливает Cookies.",
        "Наличие ошибок в консоли браузера.",
        "Настройки браузера, которые могут блокировать Cookies.",
        "Все вышеперечисленное."
    ],
    correct: ["Все вышеперечисленное."]
},
{
    question: "Если пользователь не может авторизоваться, что вы проверите в первую очередь?",
    answers: [
        "Корректность введенных данных.",
        "Наличие ошибок в консоли браузера.",
        "Настройки сервера, которые могут блокировать авторизацию.",
        "Все вышеперечисленное."
    ],
    correct: ["Все вышеперечисленное."]
},
{
    question: "Если сессия завершается раньше времени, что вы проверите?",
    answers: [
        "Корректность кода, который управляет сессией.",
        "Настройки сервера, которые могут влиять на длительность сессии.",
        "Наличие ошибок в консоли браузера.",
        "Все вышеперечисленное."
    ],
    correct: ["Все вышеперечисленное."]
},
{
    question: "Если пользователь не может выйти из системы (logout), что вы проверите?",
    answers: [
        "Корректность кода, который управляет выходом из системы.",
        "Наличие ошибок в консоли браузера.",
        "Настройки сервера, которые могут блокировать выход из системы.",
        "Все вышеперечисленное."
    ],
    correct: ["Все вышеперечисленное."]
},
{
    question: "Если данные авторизации передаются в открытом виде, что вы посоветуете?",
    answers: [
        "Перейти на использование HTTPS.",
        "Продолжать использовать HTTP.",
        "Хранить данные авторизации в Local Storage.",
        "Хранить данные авторизации в Session Storage."
    ],
    correct: ["Перейти на использование HTTPS."]
},
{
question: "Какие форматы данных могут быть использованы в теле (body) запроса или ответа RESTful API?",
answers: [
  "Только JSON",
  "JSON, XML, HTML, text, бинарные данные (например, изображения)",
  "Только XML",
  "Только plain text"
],
correct: ["JSON, XML, HTML, text, бинарные данные (например, изображения)"]
},
{
question: "Что такое XML?",
answers: [
  "XML - формат сообщения. Используется в SOAP и реже в REST",
  "XML - формат сообщения. Используется только в REST",
  "XML - это язык программирования",
  "XML - это база данных"
],
correct: ["XML - формат сообщения. Используется в SOAP и реже в REST"]
},
{
question: "Что такое JSON?",
answers: [
  "JSON - формат сообщения. Используется в REST",
  "JSON - формат сообщения. Используется в REST и реже в SOAP",
  "JSON - это язык программирования",
  "JSON - это база данных"
],
correct: ["JSON - формат сообщения. Используется в REST"]
},
{
question: "Какие типы данных представлены в JSON?",
answers: [
  "Строка, число, массив, объект, null, Boolean",
  "Только строка и число",
  "Только массив и объект",
  "Только null и Boolean"
],
correct: ["Строка, число, массив, объект, null, Boolean"]
},
{
question: "Какой тип данных используется для представления текста в JSON?",
answers: [
  "Число (number)",
  "Строка (string)",
  "Булевый тип (boolean)",
  "Массив (array)"
],
correct: ["Строка (string)"]
},
{
question: "Какой тип данных используется для представления логических значений (истина/ложь) в JSON?",
answers: [
  "Число (number)",
  "Строка (string)",
  "Булевый тип (boolean)",
  "Массив (array)"
],
correct: ["Булевый тип (boolean)"]
},
{
question: "Какой тип данных используется для представления отсутствия значения в JSON?",
answers: [
  "null.",
  "0.",
  "Пустая строка ('')",
  "undefined"
],
correct: ["null"]
},
{
question: "Какой тип данных используется для представления упорядоченного списка значений в JSON?",
answers: [
  "Объект (object)",
  "Массив (array)",
  "Строка (string)",
  "Число (number)"
],
correct: ["Массив (array)"]
},
{
question: "Какой тип данных используется для представления коллекции пар ключ-значение в JSON?",
answers: [
  "Массив (array)",
  "Объект (object)",
  "Строка (string)",
  "Число (number)"
],
correct: ["Объект (object)"]
},
{
question: "Какой тип данных используется для представления целых и дробных чисел в JSON?",
answers: [
  "Строка (string)",
  "Число (number)",
  "Булевый тип (boolean)",
  "Массив (array)"
],
correct: ["Число (number)"]
},
{
question: "Может ли JSON содержать вложенные объекты?",
answers: [
  "Нет, JSON поддерживает только плоские структуры",
  "Да, объекты могут быть вложены друг в друга",
  "Только если они представлены как строки",
  "Только если они представлены как массивы"
],
correct: ["Да, объекты могут быть вложены друг в друга"]
},
{
question: "Может ли JSON содержать вложенные массивы?",
answers: [
  "Нет, массивы должны быть только на верхнем уровне",
  "Да, массивы могут быть вложены друг в друга",
  "Только если они представлены как объекты",
  "Только если они представлены как строки"
],
correct: ["Да, массивы могут быть вложены друг в друга"]
},
{
question: "Какой тип данных используется для представления пустого объекта в JSON?",
answers: [
  "{}",
  "[]",
  "null",
  "''"
],
correct: ["{}"]
},
{
question: "Какой тип данных используется для представления пустого массива в JSON?",
answers: [
  "{}",
  "[]",
  "null",
  "''"
],
correct: ["[]"]
},
{
question: "Какой формат данных поддерживает вложенные структуры и массивы?",
answers: [
  "Только JSON",
  "Только XML",
  "JSON и XML",
  "Только plain text"
],
correct: ["JSON и XML"]
},
{
question: "Какой формат данных поддерживает комментарии?",
answers: [
  "Только JSON",
  "Только XML",
  "JSON и XML",
  "Ни один из них"
],
correct: ["Только XML"]
},
{
question: "Что такое теги в XML?",
answers: [
  "Элементы, которые используются для обозначения начала и конца элемента",
  "Элементы, которые используются для хранения данных",
  "Элементы, которые используются для описания атрибутов",
  "Элементы, которые используются для добавления комментариев"
],
correct: ["Элементы, которые используются для обозначения начала и конца элемента"]
},
{
question: "Какой символ используется для обозначения открывающего тега в XML?",
answers: [
  "<",
  ">",
  "{",
  "["
],
correct: ["<"]
},
{
question: "Какой символ используется для обозначения закрывающего тега в XML?",
answers: [
  "</",
  ">",
  "}",
  "]"
],
correct: ["</"]
},
{
question: "Какой элемент является обязательным в XML-документе?",
answers: [
  "Корневой элемент",
  "Атрибуты",
  "Комментарии",
  "Пространства имен"
],
correct: ["Корневой элемент"]
},
{
question: "Какой элемент используется для добавления комментариев в XML?",
answers: [
  "< !-- -->",
  "//",
  "/* */",
  "< comment>"
],
correct: ["< !-- -->"]
},
{
question: "Какой элемент используется для описания атрибутов в XML?",
answers: [
  "name='value'",
  "attribute='value'",
  "attr='value'",
  "key='value'"
],
correct: ["name='value'"]
},
{
question: "Какой элемент используется для описания пространств имен в XML?",
answers: [
  "xmlns",
  "namespace",
  "ns",
  "xml:ns"
],
correct: ["xmlns"]
},
{
question: "Какой элемент используется для описания вложенных элементов в XML?",
answers: [
  "Вложенные теги",
  "Атрибуты",
  "Комментарии",
  "Пространства имен"
],
correct: ["Вложенные теги"]
},
{
question: "Какой элемент используется для описания пустого элемента в XML?",
answers: [
  "< element />",
  "< element>Без пробела< /element>",
  "< element>.< /element>",
  "< element>Пробел< /element>"
],
correct: ["< element />"]
},
{
question: "Какой элемент используется для описания текста в XML?",
answers: [
  "Текст внутри тегов.",
  "Атрибуты.",
  "Комментарии.",
  "Пространства имен."
],
correct: ["Текст внутри тегов."]
},
{
question: "Какой элемент используется для описания CDATA в XML?",
answers: [
  "< ![CDATA[ ]]>",
  "< cdata> < /cdata>",
  "< data> < /data>",
  "< text> < /text>"
],
correct: ["< ![CDATA[ ]]>"]
},
{
question: "Какой элемент используется для описания обработки инструкций в XML?",
answers: [
  "< ? ?>",
  "< instruction> < /instruction>",
  "< process> < /process>",
  "< pi> < /pi>"
],
correct: ["< ? ?>"]
},
{
question: "Какой элемент используется для описания DTD в XML?",
answers: [
  "< !DOCTYPE >",
  "< dtd> < /dtd>",
  "< schema> < /schema>",
  "< definition> < /definition>"
],
correct: ["< !DOCTYPE>"]
},
{
question: "Какой элемент используется для описания схемы XML?",
answers: [
  "XSD",
  "DTD",
  "XSLT",
  "XPath"
],
correct: ["XSD"]
},
{
    question: "Что такое SOAP?",
    answers: [
        "Архитектурный стиль для создания веб-сервисов.",
        "Протокол для обмена структурированными сообщениями в компьютерных сетях.",
        "Язык программирования.",
        "Метод кэширования данных."
    ],
    correct: ["Протокол для обмена структурированными сообщениями в компьютерных сетях."]
},
{
    question: "Какой формат данных используется в SOAP?",
    answers: [
        "JSON",
        "XML",
        "CSV",
        "YAML"
    ],
    correct: ["XML"]
},
{
    question: "Где передается информация в SOAP?",
    answers: [
        "Внутри тегов < header>.",
        "Внутри тегов < body>.",
        "Внутри тегов < envelope>.",
        "Внутри тегов < fault>."
    ],
    correct: ["Внутри тегов < body>."]
},
{
    question: "Сколько существует запросов в SOAP?",
    answers: [
        "Один тип запроса.",
        "Два типа запросов.",
        "Три типа запросов.",
        "Четыре типа запросов."
    ],
    correct: ["Один тип запроса."]
},
{
    question: "Что из перечисленного характерно для SOAP?",
    answers: [
        "Использование WSDL для описания сервисов.",
        "Легковесность и простота.",
        "Использование только JSON для передачи данных.",
        "Отсутствие строгой спецификации."
    ],
    correct: ["Использование WSDL для описания сервисов."]
},
{
    question: "Какие из перечисленных особенностей относятся к SOAP? (Выберите все подходящие варианты)",
    answers: [
        "Поддержка сложных операций, таких как транзакции и безопасность.",
        "Использование XML для передачи данных.",
        "Легковесность и простота.",
        "Требование строгой спецификации."
    ],
    correct: ["Поддержка сложных операций, таких как транзакции и безопасность.", "Использование XML для передачи данных.", "Требование строгой спецификации."]
},
{
    question: "Может ли быть в SOAP в < body> ответов тег < fault>?",
    answers: [
        "Да, для передачи информации об ошибках.",
        "Нет, < fault> используется только в запросах.",
        "Нет, < fault> используется только в заголовках.",
        "Нет, < fault> не является частью SOAP."
    ],
    correct: ["Да, для передачи информации об ошибках."]
},
{
    question: "Где располагается тег < fault> в SOAP-сообщении?",
    answers: [
        "Внутри тега < header>.",
        "Внутри тега < body>.",
        "Внутри тега < envelope>.",
        "Вне структуры SOAP-сообщения."
    ],
    correct: ["Внутри тега < body>."]
},
{
    question: "Где пишется документация в SOAP?",
    answers: [
        "Документация в Swagger.",
        "Документация в WSDL.",
        "Документация в Postman.",
        "Документация в Redoc формате."
    ],
    correct: ["Документация в WSDL."]
},
{
    question: "Инструмент для тестирования в SOAP?",
    answers: [
        "Postman.",
        "SOAP UI.",
        "Swagger.",
        "Redoc."
    ],
    correct: ["SOAP UI."]
},
{
    question: "Что такое WSDL в SOAP?",
    answers: [
        "Язык описания веб-сервисов.",
        "Формат данных.",
        "Метод аутентификации.",
        "Протокол передачи данных."
    ],
    correct: ["Язык описания веб-сервисов."]
},
{
    question: "Какие преимущества использования SOAP перед REST?",
    answers: [
        "Простота реализации.",
        "Поддержка сложных операций и транзакций.",
        "Меньший объем данных.",
        "Более высокая производительность."
    ],
    correct: ["Поддержка сложных операций и транзакций."]
},
{
    question: "Какие недостатки использования SOAP?",
    answers: [
        "Высокая сложность.",
        "Ограниченная поддержка типов данных.",
        "Невозможность использования с HTTP.",
        "Отсутствие стандартов."
    ],
    correct: ["Высокая сложность."]
},
{
question: "Какие протоколы используются для связи между клиентом и бэкендом?",
answers: [
  "Только HTTP.",
  "HTTP, WebSocket, gRPC, GraphQL.",
  "Только WebSocket.",
  "Только gRPC."
],
correct: ["HTTP, WebSocket, gRPC, GraphQL."]
},
{
question: "Какие основные части HTTP-запроса?",
answers: [
  "Метод, URI, заголовки, тело.",
  "Только метод и URI.",
  "Только заголовки.",
  "Только тело."
],
correct: ["Метод, URI, заголовки, тело."]
},
{
question: "Какой элемент HTTP-запроса указывает на действие, которое нужно выполнить?",
answers: [
  "Метод (Method).",
  "URI.",
  "Заголовки (Headers).",
  "Тело (Body)."
],
correct: ["Метод (Method)."]
},
{
question: "Какой элемент HTTP-запроса указывает на ресурс, к которому обращается клиент?",
answers: [
  "Метод (Method).",
  "URI.",
  "Заголовки (Headers).",
  "Тело (Body)."
],
correct: ["URI."]
},
{
question: "Какой элемент HTTP-запроса содержит метаданные о запросе?",
answers: [
  "Метод (Method).",
  "URI.",
  "Заголовки (Headers).",
  "Тело (Body)."
],
correct: ["Заголовки (Headers)."]
},
{
question: "Какой элемент HTTP-запроса используется для передачи данных на сервер?",
answers: [
  "Метод (Method).",
  "URI.",
  "Заголовки (Headers).",
  "Тело (Body)."
],
correct: ["Тело (Body)."]
},
{
question: "Какие основные части HTTP-ответа?",
answers: [
  "Статус-код, заголовки, тело.",
  "Только статус-код.",
  "Только заголовки.",
  "Только тело."
],
correct: ["Статус-код, заголовки, тело."]
},
{
question: "Какой элемент HTTP-ответа указывает на результат выполнения запроса?",
answers: [
  "Статус-код (Status Code).",
  "Заголовки (Headers).",
  "Тело (Body).",
  "URI."
],
correct: ["Статус-код (Status Code)."]
},
{
question: "Какой элемент HTTP-ответа содержит метаданные о ответе?",
answers: [
  "Статус-код (Status Code).",
  "Заголовки (Headers).",
  "Тело (Body).",
  "URI."
],
correct: ["Заголовки (Headers)."]
},
{
question: "Какой элемент HTTP-ответа используется для передачи данных клиенту?",
answers: [
  "Статус-код (Status Code).",
  "Заголовки (Headers).",
  "Тело (Body).",
  "URI."
],
correct: ["Тело (Body)."]
},
{
question: "Какой заголовок HTTP-ответа указывает на тип содержимого?",
answers: [
  "Content-Type.",
  "Authorization.",
  "Cache-Control.",
  "Accept."
],
correct: ["Content-Type."]
},
{
question: "Какой заголовок HTTP используется для авторизации?",
answers: [
  "Content-Type",
  "Authorization",
  "Cache-Control",
  "Accept"
],
correct: ["Authorization"]
},
{
question: "Какой заголовок HTTP используется для управления кэшированием?",
answers: [
  "Content-Type",
  "Authorization",
  "Cache-Control",
  "Accept"
],
correct: ["Cache-Control"]
},
{
question: "Какой заголовок HTTP используется для указания предпочтительного формата ответа?",
answers: [
  "Content-Type",
  "Authorization",
  "Cache-Control",
  "Accept"
],
correct: ["Accept"]
},
{
question: "Что такое HTTP/2?",
answers: [
  "Новая версия HTTP с улучшенной производительностью.",
  "Протокол для передачи файлов.",
  "Язык программирования.",
  "База данных."
],
correct: ["Новая версия HTTP с улучшенной производительностью."]
},
{
question: "Что такое кэширование в HTTP?",
answers: [
  "Сохранение данных на стороне клиента для уменьшения количества запросов к серверу.",
  "Метод шифрования данных.",
  "Формат данных.",
  "Метод аутентификации."
],
correct: ["Сохранение данных на стороне клиента для уменьшения количества запросов к серверу."]
},
{
question: "Что такое безопасный метод (safe method) в HTTP?",
answers: [
  "Метод, который не изменяет состояние сервера.",
  "Метод, который шифрует данные.",
  "Метод, который использует HTTPS.",
  "Метод, который требует аутентификации."
],
correct: ["Метод, который не изменяет состояние сервера."]
},
{
question: "Какие методы HTTP являются безопасными (safe)?",
answers: [
  "GET",
  "POST",
  "PUT",
  "DELETE"
],
correct: ["GET"]
},
{
question: "Что означает идемпотентность HTTP-запроса?",
answers: [
  "Запрос может быть выполнен только один раз.",
  "Многократное выполнение запроса даёт тот же результат, что и однократное.",
  "Запрос не может быть повторён.",
  "Запрос изменяет состояние сервера каждый раз."
],
correct: ["Многократное выполнение запроса даёт тот же результат, что и однократное."]
},
{
question: "Какой HTTP-метод является идемпотентным? (Выберите все подходящие варианты)",
answers: [
  "GET",
  "POST",
  "PUT",
  "DELETE"
],
correct: ["GET", "PUT", "DELETE"]
},
{
question: "Почему метод POST не является идемпотентным?",
answers: [
  "Потому что каждый вызов POST создает новый ресурс.",
  "Потому что POST используется для запроса данных.",
  "Потому что POST удаляет ресурс.",
  "Потому что POST и PUT делают одно и то же."
],
correct: ["Потому что каждый вызов POST создает новый ресурс."]
},
{
question: "Что делает метод GET?",
answers: [
  "Запрашивает данные с сервера.",
  "Отправляет данные на сервер.",
  "Обновляет данные на сервере.",
  "Удаляет данные на сервере."
],
correct: ["Запрашивает данные с сервера."]
},
{
question: "Что делает метод POST?",
answers: [
  "Запрашивает данные с сервера.",
  "Отправляет данные на сервер для создания нового ресурса.",
  "Обновляет данные на сервере.",
  "Удаляет данные на сервере."
],
correct: ["Отправляет данные на сервер для создания нового ресурса."]
},
{
question: "Что делает метод PUT?",
answers: [
  "Запрашивает данные с сервера.",
  "Отправляет данные на сервер для создания нового ресурса.",
  "Обновляет или заменяет существующий ресурс на сервере.",
  "Удаляет данные на сервере."
],
correct: ["Обновляет или заменяет существующий ресурс на сервере."]
},
{
question: "Что делает метод DELETE?",
answers: [
  "Запрашивает данные с сервера.",
  "Отправляет данные на сервер для создания нового ресурса.",
  "Обновляет данные на сервере.",
  "Удаляет данные на сервере."
],
correct: ["Удаляет данные на сервере."]
},
{
question: "Что делает метод PATCH?",
answers: [
  "Запрашивает данные с сервера.",
  "Отправляет данные на сервер для создания нового ресурса.",
  "Частично обновляет существующий ресурс на сервере.",
  "Удаляет данные на сервере."
],
correct: ["Частично обновляет существующий ресурс на сервере."]
},
{
question: "Чем отличается метод POST от метода PUT?",
answers: [
  "POST создает новый ресурс, а PUT обновляет или заменяет существующий.",
  "POST обновляет ресурс, а PUT создает новый.",
  "POST удаляет ресурс, а PUT создает новый.",
  "POST и PUT делают одно и то же."
],
correct: ["POST создает новый ресурс, а PUT обновляет или заменяет существующий."]
},
{
question: "Чем отличается метод PUT от метода PATCH?",
answers: [
  "PUT полностью заменяет ресурс, а PATCH обновляет только часть ресурса.",
  "PUT создает новый ресурс, а PATCH удаляет ресурс.",
  "PUT и PATCH делают одно и то же.",
  "PUT используется для запроса данных, а PATCH для отправки данных."
],
correct: ["PUT полностью заменяет ресурс, а PATCH обновляет только часть ресурса."]
},
{
question: "Какой метод HTTP используется для частичного обновления ресурса?",
answers: [
  "GET",
  "POST",
  "PUT",
  "PATCH"
],
correct: ["PATCH"]
},
{
question: "Какой метод HTTP используется для полной замены ресурса?",
answers: [
  "GET",
  "POST",
  "PUT",
  "DELETE"
],
correct: ["PUT"]
},
{
question: "Какой метод HTTP используется для удаления ресурса?",
answers: [
  "GET",
  "POST",
  "PUT",
  "DELETE"
],
correct: ["DELETE"]
},
{
question: "Какой метод HTTP используется для запроса данных?",
answers: [
  "GET",
  "POST",
  "PUT",
  "DELETE"
],
correct: ["GET"]
},
{
question: "Какой метод HTTP используется для создания нового ресурса?",
answers: [
  "GET",
  "POST",
  "PUT",
  "DELETE"
],
correct: ["POST"]
},
{
    question: "Что такое Webhook?",
    answers: [
        "Метод кэширования данных.",
        "Механизм, который позволяет серверу отправлять данные клиенту в реальном времени при наступлении события.",
        "Протокол для передачи файлов.",
        "Формат данных."
    ],
    correct: ["Механизм, который позволяет серверу отправлять данные клиенту в реальном времени при наступлении события."]
},
{
    question: "Какой HTTP-метод чаще всего используется для вызова Webhook?",
    answers: [
        "GET",
        "POST",
        "PUT",
        "DELETE"
    ],
    correct: ["POST"]
},
{
    question: "Какие данные обычно передаются через Webhook?",
    answers: [
        "Только текстовые данные.",
        "JSON или XML, содержащие информацию о событии.",
        "Только бинарные данные.",
        "Только изображения."
    ],
    correct: ["JSON или XML, содержащие информацию о событии."]
},
{
    question: "Что такое GraphQL?",
    answers: [
        "Язык программирования.",
        "Язык запросов для API, который позволяет клиенту запрашивать только нужные данные.",
        "Протокол для передачи файлов.",
        "Формат данных."
    ],
    correct: ["Язык запросов для API, который позволяет клиенту запрашивать только нужные данные."]
},
{
    question: "Какое преимущество GraphQL перед REST?",
    answers: [
        "GraphQL требует меньше ресурсов сервера.",
        "GraphQL позволяет клиенту запрашивать только необходимые данные, уменьшая перегрузку сети.",
        "GraphQL поддерживает только GET-запросы.",
        "GraphQL не требует документации."
    ],
    correct: ["GraphQL позволяет клиенту запрашивать только необходимые данные, уменьшая перегрузку сети."]
},
{
    question: "Какой формат данных используется в GraphQL?",
    answers: [
        "XML",
        "JSON",
        "CSV",
        "YAML"
    ],
    correct: ["JSON"]
},
{
    question: "Что такое gRPC?",
    answers: [
        "Протокол для передачи файлов.",
        "Высокопроизводительный фреймворк для удалённого вызова процедур (RPC), использующий HTTP/2 и Protocol Buffers.",
        "Формат данных.",
        "Язык программирования."
    ],
    correct: ["Высокопроизводительный фреймворк для удалённого вызова процедур (RPC), использующий HTTP/2 и Protocol Buffers."]
},
{
    question: "Какой формат данных используется в gRPC?",
    answers: [
        "JSON",
        "XML",
        "Protocol Buffers (Protobuf)",
        "YAML"
    ],
    correct: ["Protocol Buffers (Protobuf)"]
},
{
    question: "Какое преимущество gRPC перед REST?",
    answers: [
        "gRPC поддерживает только текстовые данные.",
        "gRPC использует HTTP/2, что обеспечивает высокую производительность и низкую задержку.",
        "gRPC не требует документации.",
        "gRPC поддерживает только GET-запросы."
    ],
    correct: ["gRPC использует HTTP/2, что обеспечивает высокую производительность и низкую задержку."]
},
{
    question: "Сколько стандартных статусов (кодов) существует в gRPC?",
    answers: [
        "5",
        "10",
        "17",
        "22"
    ],
    correct: ["17"]
},
{
    question: "Какие из перечисленных статусов используются в gRPC? (Выберите все подходящие варианты)",
    answers: [
        "OK (успешное выполнение)",
        "INVALID_ARGUMENT (неверные аргументы)",
        "UNAVAILABLE (сервис недоступен)",
        "NOT_FOUND (ресурс не найден)"
    ],
    correct: ["OK (успешное выполнение)", "INVALID_ARGUMENT (неверные аргументы)", "UNAVAILABLE (сервис недоступен)", "NOT_FOUND (ресурс не найден)"]
},
{
    question: "Что такое WebSocket?",
    answers: [
        "Протокол для передачи файлов.",
        "Протокол для двусторонней связи между клиентом и сервером в реальном времени.",
        "Формат данных.",
        "Язык программирования."
    ],
    correct: ["Протокол для двусторонней связи между клиентом и сервером в реальном времени."]
},
{
    question: "Какое преимущество WebSocket перед HTTP?",
    answers: [
        "WebSocket поддерживает только одностороннюю связь.",
        "WebSocket позволяет устанавливать постоянное соединение для обмена данными в реальном времени.",
        "WebSocket не поддерживает JSON.",
        "WebSocket работает только с текстовыми данными."
    ],
    correct: ["WebSocket позволяет устанавливать постоянное соединение для обмена данными в реальном времени."]
},
{
    question: "Какой тип данных чаще всего передаётся через WebSocket?",
    answers: [
        "Только текстовые данные.",
        "JSON или бинарные данные.",
        "Только изображения.",
        "Только XML."
    ],
    correct: ["JSON или бинарные данные."]
},
{
    question: "Что такое FTP?",
    answers: [
        "Протокол для передачи файлов между клиентом и сервером.",
        "Протокол для отправки электронной почты.",
        "Формат данных.",
        "Язык программирования."
    ],
    correct: ["Протокол для передачи файлов между клиентом и сервером."]
},
{
    question: "Какой порт по умолчанию используется для FTP?",
    answers: [
        "80",
        "443",
        "21",
        "25"
    ],
    correct: ["21"]
},
{
    question: "Какие режимы передачи данных поддерживает FTP?",
    answers: [
        "Только текстовый режим.",
        "Только бинарный режим.",
        "Текстовый и бинарный режимы.",
        "Только потоковый режим."
    ],
    correct: ["Текстовый и бинарный режимы."]
},
{
    question: "Что такое SMTP?",
    answers: [
        "Протокол для передачи файлов.",
        "Протокол для отправки электронной почты.",
        "Формат данных.",
        "Язык программирования."
    ],
    correct: ["Протокол для отправки электронной почты."]
},
{
    question: "Какой порт по умолчанию используется для SMTP?",
    answers: [
        "80",
        "443",
        "25",
        "21"
    ],
    correct: ["25"]
},
{
    question: "Какие данные передаются через SMTP?",
    answers: [
        "Только текстовые данные.",
        "Электронные письма, включая текст, вложения и метаданные.",
        "Только изображения.",
        "Только JSON."
    ],
    correct: ["Электронные письма, включая текст, вложения и метаданные."]
},
{
    question: "Что такое REST?",
    answers: [
        "Протокол для передачи данных.",
        "Архитектурный стиль для создания веб-сервисов.",
        "Язык программирования.",
        "База данных."
    ],
    correct: ["Архитектурный стиль для создания веб-сервисов."]
},
{
    question: "Какой формат данных чаще всего используется в REST?",
    answers: [
        "XML",
        "JSON",
        "CSV",
        "YAML"
    ],
    correct: ["JSON"]
},
{
    question: "Что означает принцип 'единства интерфейса' (Uniform Interface) в RESTful API?",
    answers: [
        "Все запросы и ответы должны использовать только формат JSON.",
        "Интерфейс должен быть унифицированным, чтобы клиенты могли взаимодействовать с сервером через стандартные методы HTTP (GET, POST, PUT, DELETE) и URI.",
        "Сервер должен возвращать только текстовые данные.",
        "Клиент должен использовать только один метод HTTP для всех запросов."
    ],
    correct: ["Интерфейс должен быть унифицированным, чтобы клиенты могли взаимодействовать с сервером через стандартные методы HTTP (GET, POST, PUT, DELETE) и URI."]
},
{
    question: "Какие HTTP-методы используются в RESTful API? (Выберите все подходящие варианты)",
    answers: [
        "GET",
        "PUT",
        "DELETE",
        "POST",
        "PATCH"
    ],
    correct: ["GET", "PUT", "DELETE", "POST", "PATCH"]
},
{
    question: "Какой тип данных сервер может вернуть в ответ на запрос в REST?",
    answers: [
        "Только JSON.",
        "JSON, XML, HTML, код, бинарные данные (например, изображения).",
        "Только XML.",
        "Только HTML."
    ],
    correct: ["JSON, XML, HTML, код, бинарные данные (например, изображения)."]
},
{
    question: "Что из перечисленного характерно для REST?",
    answers: [
        "Часть запросов может быть закэширована.",
        "Легковесность и простота.",
        "Использование только XML для передачи данных.",
        "Требование строгой спецификации."
    ],
    correct: ["Часть запросов может быть закэширована.", "Легковесность и простота."]
},
{
    question: "Что такое пагинация в контексте RESTful API?",
    answers: [
        "Разделение данных на несколько страниц для удобства обработки.",
        "Метод кэширования данных.",
        "Способ шифрования данных.",
        "Метод аутентификации пользователей."
    ],
    correct: ["Разделение данных на несколько страниц для удобства обработки."]
},
{
    question: "Где пишется документация в REST?",
    answers: [
        "Документация обычно в Swagger или Redoc.",
        "Документация в WSDL.",
        "Документация в Postman.",
        "Документация в SOAP UI."
    ],
    correct: ["Документация обычно в Swagger или в Redoc формате."]
},
{
    question: "Инструмент для тестирования в REST?",
    answers: [
        "Postman.",
        "SOAP UI.",
        "Swagger.",
        "WSDL."
    ],
    correct: ["Postman."]
},
{
    question: "Что такое ресурс в REST?",
    answers: [
        "Файл на сервере.",
        "Объект или данные, которые могут быть доступны через API.",
        "База данных.",
        "Язык программирования."
    ],
    correct: ["Объект или данные, которые могут быть доступны через API."]
},
{
    question: "Что такое URI в контексте REST?",
    answers: [
        "Уникальный идентификатор ресурса.",
        "Протокол передачи данных.",
        "Формат данных.",
        "Метод HTTP."
    ],
    correct: ["Уникальный идентификатор ресурса."]
},
{
    question: "Что такое HATEOAS в REST?",
    answers: [
        "Принцип, при котором клиент взаимодействует с сервером через гиперссылки.",
        "Метод кэширования данных.",
        "Формат данных.",
        "Метод аутентификации."
    ],
    correct: ["Принцип, при котором клиент взаимодействует с сервером через гиперссылки."]
},
{
    question: "Как передать картинку в REST?",
    answers: [
        "Строкой ссылкой на облачное хранилище.",
        "Строкой в формате base64.",
        "Через form-data.",
        "Все перечисленные варианты."
    ],
    correct: ["Все перечисленные варианты."]
},
{
    question: "Что означает принцип многоуровневости (Layered System) в архитектуре RESTful API?",
    answers: [
        "Сервер должен состоять только из одного уровня (монолитная архитектура).",
        "Система может состоять из нескольких уровней (например, клиент, сервер, база данных), и каждый уровень взаимодействует только с соседними уровнями.",
        "Клиент должен напрямую взаимодействовать с базой данных.",
        "Все уровни системы должны использовать только один протокол передачи данных."
    ],
    correct: ["Система может состоять из нескольких уровней (например, клиент, сервер, база данных), и каждый уровень взаимодействует только с соседними уровнями."]
},
{
    question: "Как определить, какой формат данных используется в запросах и ответах RESTful API?",
    answers: [
        "По заголовку Content-Type в HTTP-запросе или ответе.",
        "По URL-адресу, который всегда указывает формат данных.",
        "По количеству символов в теле запроса или ответа.",
        "По HTTP-методу (GET, POST, PUT, DELETE)."
    ],
    correct: ["По заголовку Content-Type в HTTP-запросе или ответе."]
},
{
    question: "Что такое Local Storage?",
    answers: [
        "Временное хранилище данных, которое очищается при закрытии браузера.",
        "Постоянное хранилище данных, которое сохраняется даже после закрытия браузера.",
        "Хранилище данных, доступное только во время сессии.",
        "Хранилище данных, которое синхронизируется между устройствами."
    ],
    correct: ["Постоянное хранилище данных, которое сохраняется даже после закрытия браузера."]
},
{
    question: "Что такое Session Storage?",
    answers: [
        "Временное хранилище данных, которое очищается при закрытии вкладки или браузера.",
        "Постоянное хранилище данных, которое сохраняется даже после закрытия браузера.",
        "Хранилище данных, доступное только для одного запроса.",
        "Хранилище данных, которое синхронизируется между устройствами."
    ],
    correct: ["Временное хранилище данных, которое очищается при закрытии вкладки или браузера."]
},
{
    question: "Что такое Cookies?",
    answers: [
        "Хранилище данных, используемое для хранения больших объемов информации.",
        "Небольшие текстовые файлы, которые хранятся на стороне клиента и используются для отслеживания состояния сессии.",
        "Хранилище данных, доступное только во время сессии.",
        "Хранилище данных, которое синхронизируется между устройствами."
    ],
    correct: ["Небольшие текстовые файлы, которые хранятся на стороне клиента и используются для отслеживания состояния сессии."]
},
{
    question: "Что такое IndexedDB?",
    answers: [
        "Временное хранилище данных, которое очищается при закрытии браузера.",
        "Постоянное хранилище данных, которое сохраняется даже после закрытия браузера.",
        "Нереляционная база данных, которая позволяет хранить большие объемы структурированных данных.",
        "Хранилище данных, доступное только во время сессии."
    ],
    correct: ["Нереляционная база данных, которая позволяет хранить большие объемы структурированных данных."]
},
{
    question: "Что такое Cache Storage?",
    answers: [
        "Хранилище данных, используемое для хранения больших объемов информации.",
        "Хранилище данных, доступное только во время сессии.",
        "Хранилище данных, которое используется для кэширования ресурсов (например, файлов CSS, JS, изображений).",
        "Хранилище данных, которое синхронизируется между устройствами."
    ],
    correct: ["Хранилище данных, которое используется для кэширования ресурсов (например, файлов CSS, JS, изображений)."]
},
{
    question: "Как проверить, что данные сохраняются в Local Storage?",
    answers: [
        "Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'.",
        "Проверить вкладку 'Network' в инструментах разработчика.",
        "Проверить вкладку 'Console' в инструментах разработчика.",
        "Проверить вкладку 'Performance' в инструментах разработчика."
    ],
    correct: ["Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'."]
},
{
    question: "Как проверить, что данные удаляются из Session Storage после закрытия вкладки?",
    answers: [
        "Открыть новую вкладку и проверить данные в Session Storage.",
        "Закрыть вкладку, открыть ее снова и проверить данные в Session Storage.",
        "Проверить данные в Local Storage.",
        "Проверить данные в Cookies."
    ],
    correct: ["Закрыть вкладку, открыть ее снова и проверить данные в Session Storage."]
},
{
    question: "Как проверить, что Cookies устанавливаются корректно?",
    answers: [
        "Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'.",
        "Проверить вкладку 'Network' в инструментах разработчика.",
        "Проверить вкладку 'Console' в инструментах разработчика.",
        "Проверить вкладку 'Performance' в инструментах разработчика."
    ],
    correct: ["Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'."]
},
{
    question: "Как проверить, что данные сохраняются в IndexedDB?",
    answers: [
        "Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'.",
        "Проверить вкладку 'Network' в инструментах разработчика.",
        "Проверить вкладку 'Console' в инструментах разработчика.",
        "Проверить вкладку 'Performance' в инструментах разработчика."
    ],
    correct: ["Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'."]
},
{
    question: "Как проверить, что ресурсы кэшируются в Cache Storage?",
    answers: [
        "Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'.",
        "Проверить вкладку 'Network' в инструментах разработчика.",
        "Проверить вкладку 'Console' в инструментах разработчика.",
        "Проверить вкладку 'Performance' в инструментах разработчика."
    ],
    correct: ["Открыть инструменты разработчика (DevTools) и проверить вкладку 'Application'.", "Проверить вкладку 'Network' в инструментах разработчика."]
},
{
    question: "Если данные не сохраняются в Local Storage, что вы проверите в первую очередь?",
    answers: [
        "Корректность кода, который записывает данные.",
        "Наличие ошибок в консоли браузера.",
        "Настройки браузера, которые могут блокировать Local Storage.",
        "Все вышеперечисленное."
    ],
    correct: ["Все вышеперечисленное."]
},
{
    question: "Если Cookies не устанавливаются, что вы проверите в первую очередь?",
    answers: [
        "Корректность кода, который устанавливает Cookies.",
        "Наличие ошибок в консоли браузера.",
        "Настройки браузера, которые могут блокировать Cookies.",
        "Все вышеперечисленное."
    ],
    correct: ["Все вышеперечисленное."]
},
{
    question: "Если данные в Session Storage исчезают раньше времени, что вы проверите?",
    answers: [
        "Корректность кода, который управляет Session Storage.",
        "Не закрывается ли вкладка или браузер раньше времени.",
        "Настройки браузера, которые могут влиять на Session Storage.",
        "Все вышеперечисленное."
    ],
    correct: ["Все вышеперечисленное."]
},
{
    question: "Если IndexedDB не сохраняет данные, что вы проверите в первую очередь?",
    answers: [
        "Корректность кода, который работает с IndexedDB.",
        "Наличие ошибок в консоли браузера.",
        "Настройки браузера, которые могут блокировать IndexedDB.",
        "Все вышеперечисленное."
    ],
    correct: ["Все вышеперечисленное."]
},
{
    question: "Если ресурсы не кэшируются в Cache Storage, что вы проверите?",
    answers: [
        "Корректность кода, который управляет кэшированием.",
        "Наличие ошибок в консоли браузера.",
        "Настройки браузера, которые могут блокировать Cache Storage.",
        "Все вышеперечисленное."
    ],
    correct: ["Все вышеперечисленное."]
},
{
    question: "Что обозначают HTTP-статусы в диапазоне 100-199?",
    answers: ["Успешные запросы", "Информационные статусы", "Клиентские ошибки", "Серверные ошибки"],
    correct: ["Информационные статусы"]
},
{
    question: "Что обозначают HTTP-статусы в диапазоне 200-299?",
    answers: ["Перенаправления", "Успешные запросы", "Клиентские ошибки", "Серверные ошибки"],
    correct: ["Успешные запросы"]
},
{
    question: "Что обозначают HTTP-статусы в диапазоне 300-399?",
    answers: ["Информационные статусы", "Успешные запросы", "Перенаправления", "Серверные ошибки"],
    correct: ["Перенаправления"]
},
{
    question: "Что обозначают HTTP-статусы в диапазоне 400-499?",
    answers: ["Информационные статусы", "Успешные запросы", "Клиентские ошибки", "Серверные ошибки"],
    correct: ["Клиентские ошибки"]
},
{
    question: "Что обозначают HTTP-статусы в диапазоне 500-599?",
    answers: ["Информационные статусы", "Успешные запросы", "Клиентские ошибки", "Серверные ошибки"],
    correct: ["Серверные ошибки"]
},
{
    question: "Что означает статус 200?",
    answers: ["Запрос успешно обработан", "Запрос перенаправлен", "Ошибка на стороне клиента", "Ошибка на стороне сервера"],
    correct: ["Запрос успешно обработан"]
},
{
    question: "Что означает статус 201?",
    answers: ["Запрос успешно обработан", "Ресурс успешно создан", "Запрос перенаправлен", "Ошибка на стороне клиента"],
    correct: ["Ресурс успешно создан"]
},
{
    question: "Что означает статус 301?",
    answers: ["Запрос успешно обработан", "Ресурс временно перемещен", "Ресурс переехал на другой домен", "Ошибка на стороне клиента"],
    correct: ["Ресурс переехал на другой домен"]
},
{
    question: "Что означает статус 401?",
    answers: ["Запрос успешно обработан", "Необходима авторизация", "Доступ запрещен", "Ресурс не найден"],
    correct: ["Необходима авторизация"]
},
{
    question: "Что означает статус 403?",
    answers: ["Запрос успешно обработан", "Необходима авторизация", "Доступ запрещен", "Ресурс не найден"],
    correct: ["Доступ запрещен"]
},
{
    question: "Что означает статус 404?",
    answers: ["Запрос успешно обработан", "Необходима авторизация", "Доступ запрещен", "Ресурс не найден"],
    correct: ["Ресурс не найден"]
},
{
    question: "Что означает статус 418?",
    answers: ["Запрос успешно обработан", "Я чайник", "Ошибка на стороне сервера", "Ресурс не найден"],
    correct: ["Я чайник"]
},
{
    question: "Что означает статус 500?",
    answers: ["Запрос успешно обработан", "Ошибка на стороне клиента", "Ошибка на стороне сервера", "Ресурс не найден"],
    correct: ["Ошибка на стороне сервера"]
},
{
    question: "Что означает статус 504?",
    answers: ["Запрос успешно обработан", "Ошибка на стороне клиента", "Таймаут шлюза", "Ресурс не найден"],
    correct: ["Таймаут шлюза"]
},
{
    question: "Почему важно понимать HTTP-статусы при тестировании веб-приложений?",
    answers: ["Чтобы правильно интерпретировать ответы сервера", "Чтобы быстрее находить ошибки", "Чтобы улучшить пользовательский интерфейс", "Все вышеперечисленное"],
    correct: ["Все вышеперечисленное"]
},
{
    question: "Какой инструмент вы используете для просмотра HTTP-статусов ответов сервера?",
    answers: ["Браузер", "Инструменты разработчика (DevTools)", "Текстовый редактор", "Графический редактор"],
    correct: ["Инструменты разработчика (DevTools)"]
},
{
    question: "Как вы проверите, что сервер возвращает статус 404 при запросе несуществующей страницы?",
    answers: ["Отправить запрос на несуществующий URL и проверить статус ответа", "Отправить запрос на существующий URL и проверить статус ответа", "Отправить запрос на главную страницу и проверить статус ответа", "Ничего из вышеперечисленного"],
    correct: ["Отправить запрос на несуществующий URL и проверить статус ответа"]
},
{
    question: "Как вы проверите, что сервер возвращает статус 301 при перенаправлении на другой URL?",
    answers: ["Отправить запрос на старый URL и проверить статус ответа", "Отправить запрос на новый URL и проверить статус ответа", "Отправить запрос на главную страницу и проверить статус ответа", "Ничего из вышеперечисленного"],
    correct: ["Отправить запрос на старый URL и проверить статус ответа"]
},
{
    question: "Если вы видите статус 500 при тестировании, какие шаги вы предпримете для диагностики проблемы?",
    answers: ["Проверить логи сервера", "Проверить корректность запроса", "Связаться с разработчиками", "Все вышеперечисленное"],
    correct: ["Все вышеперечисленное"]
},
{
    question: "Если клиент получает статус 403, что вы посоветуете проверить в первую очередь?",
    answers: ["Корректность авторизации", "Наличие необходимых прав доступа", "Корректность URL", "Все вышеперечисленное"],
    correct: ["Все вышеперечисленное"]
},
{
    question: "Какой HTTP-статус обычно возвращается при успешной авторизации?",
    answers: [
        "200 OK",
        "401 Unauthorized",
        "403 Forbidden",
        "404 Not Found"
    ],
    correct: ["200 OK"]
},
{
    question: "Какой HTTP-статус обычно возвращается при отсутствии авторизации?",
    answers: [
        "200 OK",
        "401 Unauthorized",
        "403 Forbidden",
        "404 Not Found"
    ],
    correct: ["401 Unauthorized"]
},
{
    question: "Какой HTTP-статус обычно возвращается при отсутствии доступа к ресурсу?",
    answers: [
        "200 OK",
        "401 Unauthorized",
        "403 Forbidden",
        "404 Not Found"
    ],
    correct: ["403 Forbidden"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрашиваемый ресурс не найден?",
    answers: [
        "200 OK",
        "401 Unauthorized",
        "403 Forbidden",
        "404 Not Found"
    ],
    correct: ["404 Not Found"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если сервер столкнулся с внутренней ошибкой?",
    answers: [
        "500 Internal Server Error",
        "502 Bad Gateway",
        "503 Service Unavailable",
        "504 Gateway Timeout"
    ],
    correct: ["500 Internal Server Error"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если сервер временно недоступен?",
    answers: [
        "500 Internal Server Error",
        "502 Bad Gateway",
        "503 Service Unavailable",
        "504 Gateway Timeout"
    ],
    correct: ["503 Service Unavailable"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если сервер действует как шлюз и получил недействительный ответ?",
    answers: [
        "500 Internal Server Error",
        "502 Bad Gateway",
        "503 Service Unavailable",
        "504 Gateway Timeout"
    ],
    correct: ["502 Bad Gateway"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если сервер действует как шлюз и не получил ответ вовремя?",
    answers: [
        "500 Internal Server Error",
        "502 Bad Gateway",
        "503 Service Unavailable",
        "504 Gateway Timeout"
    ],
    correct: ["504 Gateway Timeout"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, но ответ пуст?",
    answers: [
        "200 OK",
        "204 No Content",
        "400 Bad Request",
        "404 Not Found"
    ],
    correct: ["204 No Content"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был некорректным?",
    answers: [
        "200 OK",
        "400 Bad Request",
        "401 Unauthorized",
        "404 Not Found"
    ],
    correct: ["400 Bad Request"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос требует аутентификации, но она не была предоставлена?",
    answers: [
        "200 OK",
        "401 Unauthorized",
        "403 Forbidden",
        "404 Not Found"
    ],
    correct: ["401 Unauthorized"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, и был создан новый ресурс?",
    answers: [
        "200 OK",
        "201 Created",
        "204 No Content",
        "400 Bad Request"
    ],
    correct: ["201 Created"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, но ответ содержит измененный ресурс?",
    answers: [
        "200 OK",
        "201 Created",
        "204 No Content",
        "304 Not Modified"
    ],
    correct: ["304 Not Modified"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, но ответ содержит перенаправление?",
    answers: [
        "301 Moved Permanently",
        "302 Found",
        "303 See Other",
        "Все вышеперечисленные"
    ],
    correct: ["Все вышеперечисленные"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, но ответ содержит перенаправление на другой URI?",
    answers: [
        "301 Moved Permanently",
        "302 Found",
        "303 See Other",
        "304 Not Modified"
    ],
    correct: ["302 Found"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, но ответ содержит перенаправление на другой URI с использованием GET?",
    answers: [
        "301 Moved Permanently",
        "302 Found",
        "303 See Other",
        "304 Not Modified"
    ],
    correct: ["303 See Other"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, но ответ содержит перенаправление на другой URI, который был перемещен навсегда?",
    answers: [
        "301 Moved Permanently",
        "302 Found",
        "303 See Other",
        "304 Not Modified"
    ],
    correct: ["301 Moved Permanently"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, но ответ содержит перенаправление на другой URI, который был перемещен временно?",
    answers: [
        "301 Moved Permanently",
        "302 Found",
        "303 See Other",
        "304 Not Modified"
    ],
    correct: ["302 Found"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, но ответ содержит перенаправление на другой URI с использованием GET?",
    answers: [
        "301 Moved Permanently",
        "302 Found",
        "303 See Other",
        "304 Not Modified"
    ],
    correct: ["303 See Other"]
},
{
    question: "Какой HTTP-статус обычно возвращается, если запрос был успешно обработан, но ответ содержит перенаправление на другой URI, который был перемещен навсегда?",
    answers: [
        "301 Moved Permanently",
        "302 Found",
        "303 See Other",
        "304 Not Modified"
    ],
    correct: ["301 Moved Permanently"]
},
{
    "question": "Что такое Postman?",
    "answers": [
        "Инструмент для создания графических интерфейсов.",
        "Инструмент для работы с базами данных.",
        "Инструмент для тестирования API.",
        "Инструмент для анализа производительности сети."
    ],
    "correct": ["Инструмент для тестирования API."]
},
{
    "question": "Какую основную функцию выполняет Postman?",
    "answers": [
        "Генерация тестовых данных.",
        "Написание unit-тестов.",
        "Создание и выполнение HTTP-запросов.",
        "Оптимизация работы базы данных."
    ],
    "correct": ["Создание и выполнение HTTP-запросов."]
},
{
    "question": "Что такое коллекция в Postman?",
    "answers": [
        "Набор запросов, объединенных в одну группу.",
        "Набор тестовых данных.",
        "Набор переменных окружения.",
        "Набор инструментов для отладки."
    ],
    "correct": ["Набор запросов, объединенных в одну группу."]
},
{
    "question": "Как создать новый запрос в Postman?",
    "answers": [
        "Нажать на кнопку 'New' и выбрать 'Environment'.",
        "Нажать на кнопку 'New' и выбрать 'Collection'.",
        "Нажать на кнопку 'New' и выбрать 'Workspace'.",
        "Нажать на кнопку 'New' и выбрать 'Request'."
    ],
    "correct": ["Нажать на кнопку 'New' и выбрать 'Request'."]
},
{
    "question": "Что такое переменные окружения в Postman?",
    "answers": [
        "Набор переменных, которые можно использовать в запросах и тестах.",
        "Набор тестовых данных.",
        "Набор запросов.",
        "Набор инструментов для отладки."
    ],
    "correct": ["Набор переменных, которые можно использовать в запросах и тестах."]
},
{
    "question": "Как добавить переменную окружения в Postman?",
    "answers": [
        "Перейти в раздел 'Collections', создать новую коллекцию и добавить переменные.",
        "Перейти в раздел 'Environments', создать новое окружение и добавить переменные.",
        "Перейти в раздел 'Requests', создать новый запрос и добавить переменные.",
        "Перейти в раздел 'Post-response', создать новый тест и добавить переменные."
    ],
    "correct": ["Перейти в раздел 'Environments', создать новое окружение и добавить переменные."]
},
{
    "question": "Что такое сниппеты в Postman?",
    "answers": [
        "Набор тестовых данных.",
        "Набор запросов.",
        "Набор инструментов для отладки.",
        "Предопределенные фрагменты кода, которые можно использовать в тестах и запросах."
    ],
    "correct": ["Предопределенные фрагменты кода, которые можно использовать в тестах и запросах."]
},
{
    "question": "8. Как добавить сниппет в тест после выполнения запроса в Postman?",
    "answers": [
        "В разделе 'Pre-request' нажать на кнопку 'Snippets' и выбрать нужный сниппет.",
        "В разделе 'Body' нажать на кнопку 'Snippets' и выбрать нужный сниппет.",
        "В разделе 'Post-response' нажать на кнопку 'Snippets' и выбрать нужный сниппет.",
        "В разделе 'Headers' нажать на кнопку 'Snippets' и выбрать нужный сниппет."
    ],
    "correct": ["В разделе 'Post-response' нажать на кнопку 'Snippets' и выбрать нужный сниппет."]
},
{
    "question": "Что такое скрипты в Postman?",
    "answers": [
        "Код, который выполняется до или после запроса.",
        "Набор тестовых данных.",
        "Набор запросов.",
        "Набор инструментов для отладки."
    ],
    "correct": ["Код, который выполняется до или после запроса."]
},
{
    "question": "Где можно добавить скрипты в Postman?",
    "answers": [
        "В разделе 'Body'.",
        "В разделе 'Headers'.",
        "В разделах 'Pre-request' и 'Post-response'.",
        "В разделе 'Environments'."
    ],
    "correct": ["В разделах 'Pre-request' и 'Post-response'."]
},
{
    "question": "Как выполнить несколько итераций запроса подряд в Postman?",
    "answers": [
        "Использовать функцию 'Run collection' в выдающем списке коллекции и указать количество итераций.",
        "Использовать функцию 'Collections' и указать количество итераций.",
        "Использовать функцию 'Environments' и указать количество итераций.",
        "Использовать функцию 'Post-response' и указать количество итераций."
    ],
    "correct": ["Использовать функцию 'Run collection' в выдающем списке коллекции и указать количество итераций."]
},
{
    "question": "Как проверить результат выполнения запроса в Postman?",
    "answers": [
        "В разделе 'Post-response' написать скрипт для проверки результата.",
        "В разделе 'Pre-request' написать скрипт для проверки результата.",
        "В разделе 'Body' написать скрипт для проверки результата.",
        "В разделе 'Headers' написать скрипт для проверки результата."
    ],
    "correct": ["В разделе 'Post-response' написать скрипт для проверки результата."]
},
{
    "question": "В какой момент в Postman запускается скрипт написанный в Pre-request?",
    "answers": [
        "После получения ответа.",
        "Перед отправкой запроса.",
        "При ошибке запроса.",
        "После отправки запроса."
    ],
    "correct": ["Перед отправкой запроса."]
},
{
    "question": "В какой момент в Postman запускается скрипт написанный в Post-response?",
    "answers": [
        "После получения ответа от сервера.",
        "Перед отправкой запроса.",
        "При ошибке запроса.",
        "После отправки запроса."
    ],
    "correct": ["После получения ответа от сервера."]
},
{
    "question": "15. Как в Postman можно проверить статус-код ответа 200 в Post-response?",
    "answers": [
        "Использовать pm.response.to.have.status(200).",
        "Использовать pm.response.code === 200.",
        "Использовать pm.response.status === '200'.",
        "Использовать pm.response.statusCode === 200."
    ],
    "correct": ["Использовать pm.response.to.have.status(200)."]
},
{
    "question": "Как в Postman можно использовать данные из ответа в следующем запросе?",
    "answers": [
        "Сохранить данные в переменные через Post-response и использовать их в следующем запросе.",
        "Использовать Pre-request для извлечения данных из предыдущего ответа.",
        "Вручную скопировать данные из ответа и вставить в следующий запрос.",
        "Использовать функцию 'Runner' для передачи данных между запросами."
    ],
    "correct": ["Сохранить данные в переменные через Post-response и использовать их в следующем запросе."]
},
{
    "question": "Что такое Content-Type в HTTP-запросе?",
    "answers": [
        "Заголовок, который указывает метод HTTP-запроса (GET, POST и т.д.).",
        "Заголовок, который указывает тип данных, передаваемых в теле запроса или ответа.",
        "Заголовок, который указывает статус ответа сервера.",
        "Заголовок, который указывает версию HTTP-протокола."
    ],
    "correct": ["Заголовок, который указывает тип данных, передаваемых в теле запроса или ответа."]
},
{
    "question": "Какие значения может принимать Content-Type?",
    "answers": [
        "application/json, application/xml, text/plain, multipart/form-data и другие.",
        "Только application/json и text/plain.",
        "Только multipart/form-data.",
        "Только application/xml."
    ],
    "correct": ["application/json, application/xml, text/plain, multipart/form-data и другие."]
},
{
    "question": "Как установить Content-Type в Postman?",
    "answers": [
        "В разделе 'Pre-request' добавить заголовок Content-Type.",
        "В разделе 'Post-response' добавить заголовок Content-Type.",
        "В разделе 'Headers' добавить заголовок Content-Type с нужным значением.",
        "В разделе 'Body' выбрать нужный тип данных (например, JSON, form-data)."
    ],
    "correct": [
        "В разделе 'Headers' добавить заголовок Content-Type с нужным значением.",
        "В разделе 'Body' выбрать нужный тип данных (например, JSON, form-data)."
    ]
},
{
    "question": "Какой Content-Type используется для передачи JSON-данных?",
    "answers": [
        "text/plain.",
        "application/json.",
        "multipart/form-data.",
        "application/xml."
    ],
    "correct": ["application/json."]
},
{
    "question": "Какой Content-Type используется для передачи файлов в Postman?",
    "answers": [
        "application/json.",
        "text/plain.",
        "application/xml.",
        "multipart/form-data."
    ],
    "correct": ["multipart/form-data."]
},
{
    "question": "Что такое монолитная архитектура?",
    "answers": [
        "Архитектура, где приложение разбито на множество независимых сервисов.",
        "Архитектура, где все компоненты приложения тесно связаны и работают как единое целое.",
        "Архитектура, где каждая функция приложения работает на отдельном сервере."
    ],
    "correct": ["Архитектура, где все компоненты приложения тесно связаны и работают как единое целое."]
},
{
    "question": "Что такое микросервисная архитектура?",
    "answers": [
        "Архитектура, где приложение состоит из множества независимых сервисов, каждый из которых выполняет одну функцию.",
        "Архитектура, где все компоненты приложения тесно связаны и работают как единое целое.",
        "Архитектура, где приложение работает только на одном сервере."
    ],
    "correct": ["Архитектура, где приложение состоит из множества независимых сервисов, каждый из которых выполняет одну функцию."]
},
{
    "question": "Какие из перечисленных преимуществ относятся к монолитной архитектуре? (Выберите все подходящие варианты)",
    "answers": [
        "Простота разработки.",
        "Легкость масштабирования отдельных компонентов.",
        "Простота тестирования, так как все компоненты находятся в одном месте.",
        "Высокая отказоустойчивость за счет изоляции сервисов."
    ],
    "correct": ["Простота разработки.", "Простота тестирования, так как все компоненты находятся в одном месте."]
},
{
    "question": "Какие из перечисленных недостатков относятся к монолитной архитектуре? (Выберите все подходящие варианты)",
    "answers": [
        "Сложность масштабирования.",
        "Высокая связанность компонентов, что усложняет внесение изменений.",
        "Сложность в поиске и устранении багов из-за распределенности системы.",
        "Низкая отказоустойчивость, так как сбой в одном компоненте может повлиять на все приложение."
    ],
    "correct": ["Сложность масштабирования.", "Высокая связанность компонентов, что усложняет внесение изменений.", "Низкая отказоустойчивость, так как сбой в одном компоненте может повлиять на все приложение."]
},
{
    "question": "Какие из перечисленных преимуществ относятся к микросервисной архитектуре? (Выберите все подходящие варианты)",
    "answers": [
        "Легкость масштабирования отдельных компонентов.",
        "Высокая отказоустойчивость за счет изоляции сервисов.",
        "Простота разработки.",
        "Упрощение тестирования за счет независимости сервисов."
    ],
    "correct": ["Легкость масштабирования отдельных компонентов.", "Высокая отказоустойчивость за счет изоляции сервисов.", "Упрощение тестирования за счет независимости сервисов."]
},
{
    "question": "Какие из перечисленных недостатков относятся к микросервисной архитектуре? (Выберите все подходящие варианты)",
    "answers": [
        "Сложность управления множеством сервисов.",
        "Высокие требования к инфраструктуре.",
        "Простота внесения изменений в один компонент без влияния на другие.",
        "Сложность тестирования из-за распределенности системы."
    ],
    "correct": ["Сложность управления множеством сервисов.", "Высокие требования к инфраструктуре.", "Сложность тестирования из-за распределенности системы."]
},
{
    "question": "Какой тип архитектуры лучше подходит для небольших проектов с ограниченными ресурсами?",
    "answers": [
        "Микросервисы.",
        "Монолит.",
        "Оба варианта одинаково подходят."
    ],
    "correct": ["Монолит."]
},
{
    "question": "8. Какой тип архитектуры лучше подходит для крупных проектов с высокими требованиями к масштабируемости и отказоустойчивости?",
    "answers": [
        "Микросервисы.",
        "Монолит.",
        "Оба варианта одинаково подходят."
    ],
    "correct": ["Микросервисы."]
},
{
    "question": "Что такое API?",
    "answers": [
        "Это протокол для передачи данных.",
        "Это язык программирования для создания бэкенда.",
        "Это интерфейс, с помощью которого можно взаимодействовать с бэкендом."
    ],
    "correct": ["Это интерфейс, с помощью которого можно взаимодействовать с бэкендом."]
},
{
    "question": "Где чаще всего хранится документация к API?",
    "answers": [
        "В браузере вместе с куками.",
        "В Kibana.",
        "В Swagger.",
        "В DevTools."
    ],
    "correct": ["В Swagger."]
},
{
    "question": "В чём особенность хранения документации в Swagger?",
    "answers": [
        "Можно сразу в Swagger настроить Pre-request.",
        "Можно сразу в Swagger создать переменные.",
        "Можно сразу в Swagger написать автотест.",
        "Можно сразу в Swagger выполнить запрос."
    ],
    "correct": ["Можно сразу в Swagger выполнить запрос."]
},
{
    "question": "Разработчик просит у тебя cUrl запроса, где его найти?",
    "answers": [
        "В DevTools во вкладке Performance.",
        "В DevTools во вкладке Elements.",
        "В DevTools во вкладке Network.",
        "В DevTools во вкладке Source."
    ],
    "correct": ["В DevTools во вкладке Network."]
},
{
    "question": "Что такое пагинация?",
    "answers": [
        "Это процесс разбиения данных на отдельные страницы.",
        "Это метод оптимизации базы данных.",
        "Это способ кэширования данных.",
        "Это тип API-запроса."
    ],
    "correct": ["Это процесс разбиения данных на отдельные страницы."]
},
{
    "question": "Сколько квери параметров можно передать в одном запросе?",
    "answers": [
        "Не более 10.",
        "Не более 50.",
        "Сколько угодно, но в рамках длины URL в 2048 символов.",
        "Не более 100."
    ],
    "correct": ["Сколько угодно, но в рамках длины URL в 2048 символов."]
}];

// Массив для хранения индексов уже заданных вопросов
let askedQuestions = [];

// Функция для загрузки случайного вопроса
function loadRandomQuestion() {
    const questionContainer = document.getElementById('game-question-container');
    const answersContainer = document.getElementById('game-answers-container');
    if (!questionContainer || !answersContainer) return;

    // Если все вопросы уже заданы, завершаем игру
    if (askedQuestions.length >= questions.length) {
        localStorage.setItem('finalScore', score);
        localStorage.setItem('finalErrors', errors);
        window.location.href = 'end.html';
        return;
    }

    // Выбираем случайный вопрос из массива, исключая уже заданные
    let randomIndex;
    do {
        randomIndex = Math.floor(Math.random() * questions.length);
    } while (askedQuestions.includes(randomIndex));

    const question = questions[randomIndex];

    // Добавляем индекс вопроса в список заданных
    askedQuestions.push(randomIndex);

    // Отображаем вопрос
    questionContainer.innerHTML = `<h3>${question.question}</h3>`;

    // Очищаем контейнер с ответами
    answersContainer.innerHTML = '';

    // Перемешиваем ответы
    shuffleArray(question.answers);

    // Определяем тип input: radio для одного ответа, checkbox для нескольких
    const inputType = question.correct.length === 1 ? 'radio' : 'checkbox';

    // Добавляем варианты ответов
    question.answers.forEach(answer => {
        answersContainer.innerHTML += `
            <label class="answer-item">
                <input type="${inputType}" name=question value="${answer}">
                <span>${answer}</span>
            </label>`;
    });

    // Очищаем feedback
    const feedback = document.getElementById('game-feedback');
    if (feedback) feedback.innerHTML = '';

    // Показываем кнопку "Проверить" и скрываем кнопку "Далее"
    document.getElementById('game-check-answer').style.display = 'inline-block';
    document.getElementById('game-next-question').style.display = 'none';
}

// Функция для проверки ответа
function checkAnswer() {
    const selected = [...document.querySelectorAll('input[name=question]:checked')].map(input => input.value);
    const question = questions.find(q => q.question === document.getElementById('game-question-container').textContent.trim());
    const isCorrect = selected.length === question.correct.length && selected.every(answer => question.correct.includes(answer));

    const feedback = document.getElementById('game-feedback');
    if (feedback) {
        if (isCorrect) {
            score++;
            feedback.innerHTML = `<p class="correct-answer">Правильно!</p>`;
        } else {
            errors++;
            feedback.innerHTML = `
                <p class="incorrect-answer">Не правильно!</p>
                <p class="correct-answer">Правильный ответ: ${question.correct.join(', ')}</p>
            `;
        }
    }

    // Обновляем счет и ошибки
    const currentScore = document.getElementById('game-current-score');
    if (currentScore) currentScore.textContent = score;
    const gameErrors = document.getElementById('game-errors');
    if (gameErrors) gameErrors.textContent = `${errors}/${maxErrors}`;

    // Скрываем кнопку "Проверить" и показываем кнопку "Далее"
    document.getElementById('game-check-answer').style.display = 'none';
    document.getElementById('game-next-question').style.display = 'block';

    // Проверяем, достигнуто ли максимальное количество ошибок
    if (errors >= maxErrors) {
        localStorage.setItem('finalScore', score);
        localStorage.setItem('finalErrors', errors);
        window.location.href = 'end.html';
    }
}

// Функция для перехода к следующему вопросу
function nextQuestion() {
    loadRandomQuestion(); // Загружаем новый случайный вопрос
}

// Функция для перемешивания массива (Fisher-Yates shuffle)
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// Инициализация страницы
if (document.getElementById('start-screen')) {
    // Начальная страница
    const startGameButton = document.getElementById('start-game');
    if (startGameButton) {
        startGameButton.addEventListener('click', function () {
            playerName = document.getElementById('player-name').value;
            if (!playerName) {
                alert("Пожалуйста, введите ваше имя.");
                return;
            }
            localStorage.setItem('playerName', playerName);
            askedQuestions = []; // Очищаем список заданных вопросов
            window.location.href = 'game.html';
        });
    }
} else if (document.getElementById('game-top')) {
    // Страница игры
    const gamePlayerName = document.getElementById('game-player-name');
    if (gamePlayerName) {
        gamePlayerName.textContent = localStorage.getItem('playerName');
    }

    // Обработчик нажатия клавиши "Пробел"
    document.addEventListener('keydown', function (event) {
        if (event.code === 'Space') {
            const activeButton = document.querySelector('#game-button-container button:not([style*="display: none"])');
            if (activeButton) activeButton.click();
        }
    });

    // Кнопка "Завершить досрочно"
    const endEarlyButton = document.getElementById('game-end-early');
    if (endEarlyButton) {
        endEarlyButton.addEventListener('click', function () {
            localStorage.setItem('finalScore', score);
            localStorage.setItem('finalErrors', errors);
            window.location.href = 'end.html';
        });
    }

    // Кнопка "Проверить"
    const checkAnswerButton = document.getElementById('game-check-answer');
    if (checkAnswerButton) checkAnswerButton.addEventListener('click', checkAnswer);

    // Кнопка "Далее"
    const nextQuestionButton = document.getElementById('game-next-question');
    if (nextQuestionButton) nextQuestionButton.addEventListener('click', nextQuestion);

    loadRandomQuestion(); // Загрузка первого случайного вопроса
} else if (document.getElementById('end-screen')) {
    // Страница завершения игры
    const finalScore = document.getElementById('end-final-score');
    if (finalScore) finalScore.textContent = localStorage.getItem('finalScore');

    const endErrors = document.getElementById('end-errors');
    if (endErrors) endErrors.textContent = localStorage.getItem('finalErrors');

    // Кнопка "Еще раз"
    const restartButton = document.getElementById('end-restart-game');
    if (restartButton) {
        restartButton.addEventListener('click', function () {
            localStorage.removeItem('finalScore'); // Очищаем только финальные данные
            localStorage.removeItem('finalErrors');
            window.location.href = 'index.html';
        });
    }
}

// Обработчик для кнопки "Вернуться на главную"
const returnHomeButton = document.getElementById('return-home');
if (returnHomeButton) {
    returnHomeButton.addEventListener('click', function () {
        console.log("Кнопка 'Вернуться на главную' нажата!"); // Проверка
        window.location.href = '../index.html'; // Переход на главную
    });
}

// Блок добавления иконки

function addFaviconsAndMeta() {
    const head = document.head;

    // Apple Touch Icons
    const appleIcons = [
        { sizes: "57x57", href: "../ico/apple-icon-57x57.png" },
        { sizes: "60x60", href: "../ico/apple-icon-60x60.png" },
        { sizes: "72x72", href: "../ico/apple-icon-72x72.png" },
        { sizes: "76x76", href: "../ico/apple-icon-76x76.png" },
        { sizes: "114x114", href: "../ico/apple-icon-114x114.png" },
        { sizes: "120x120", href: "../ico/apple-icon-120x120.png" },
        { sizes: "144x144", href: "../ico/apple-icon-144x144.png" },
        { sizes: "152x152", href: "../ico/apple-icon-152x152.png" },
        { sizes: "180x180", href: "../ico/apple-icon-180x180.png" },
    ];

    appleIcons.forEach(icon => {
        const link = document.createElement('link');
        link.rel = 'apple-touch-icon';
        link.sizes = icon.sizes;
        link.href = icon.href;
        head.appendChild(link);
    });

    // Favicons
    const favicons = [
        { type: "image/png", sizes: "192x192", href: "../ico/android-icon-192x192.png" },
        { type: "image/png", sizes: "32x32", href: "../ico/favicon-32x32.png" },
        { type: "image/png", sizes: "96x96", href: "../ico/favicon-96x96.png" },
        { type: "image/png", sizes: "16x16", href: "../ico/favicon-16x16.png" },
    ];

    favicons.forEach(favicon => {
        const link = document.createElement('link');
        link.rel = 'icon';
        link.type = favicon.type;
        link.sizes = favicon.sizes;
        link.href = favicon.href;
        head.appendChild(link);
    });

    // Manifest
    const manifestLink = document.createElement('link');
    manifestLink.rel = 'manifest';
    manifestLink.href = 'ico/manifest.json';
    head.appendChild(manifestLink);

    // MSApplication Meta Tags
    const msTileColor = document.createElement('meta');
    msTileColor.name = 'msapplication-TileColor';
    msTileColor.content = '#ffffff';
    head.appendChild(msTileColor);

    const msTileImage = document.createElement('meta');
    msTileImage.name = 'msapplication-TileImage';
    msTileImage.content = '/ms-icon-144x144.png';
    head.appendChild(msTileImage);

    // Theme Color
    const themeColor = document.createElement('meta');
    themeColor.name = 'theme-color';
    themeColor.content = '#ffffff';
    head.appendChild(themeColor);
}

// Вызов функции для добавления элементов
addFaviconsAndMeta();