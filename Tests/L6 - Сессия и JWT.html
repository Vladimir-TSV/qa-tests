<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Сессия и JWT</title>
<link rel="stylesheet" href="styles.css">
<script src="script.js" defer></script>

</head>
<body>
<div class="fixed-top" id="fixedTop">
    <button class="check-btn" onclick="checkAnswers()" style="display: none;">Проверить</button>
    <button class="reset-btn" onclick="resetTest()" style="display: none;">Начать заново</button>
    <a href="../index.html" class="return-button">Вернуться на главную</a>
</div>

<div id="startContainer">
    <h1>Сессия и JWT</h1>
    <button class="start-btn" onclick="startTest()">Начать тест</button>
</div>

<div id="testContainer">
</div>

<div id="results">
    <h3>Результаты:</h3>
    <ul id="resultList"></ul>
</div>

<script>
const questions = [
{
  "question": "Что такое сессии при авторизации?",
  "answers": [
    "Механизм хранения состояния пользователя на сервере между запросами",
    "Токен для доступа к API",
    "Шифрованный пароль пользователя",
    "Лог действий пользователя"
  ],
  "correct": ["Механизм хранения состояния пользователя на сервере между запросами"],
  "comment": "Сессии обычно используют cookie с session ID."
},
{
  "question": "Что такое JWT?",
  "answers": [
    "Стандарт для создания токенов в формате JSON с цифровой подписью",
    "Протокол для шифрования паролей",
    "Система кэширования запросов",
    "Метод аутентификации через SMS"
  ],
  "correct": ["Стандарт для создания токенов в формате JSON с цифровой подписью"]
},
{
  "question": "Из каких частей состоит JWT?",
  "answers": [
    "Header.Payload.Signature",
    "Login.Password.Hash",
    "Key.Value.Expiry",
    "UserID.Session.Data"
  ],
  "correct": ["Header.Payload.Signature"],
  "comment": "Пример: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
},
{
  "question": "Что означает Stateless в авторизации?",
  "answers": [
    "Сервер не хранит состояние пользователя (например, JWT)",
    "Сервер хранит сессии в памяти/БД",
    "Отсутствие токенов",
    "Использование только cookie"
  ],
  "correct": ["Сервер не хранит состояние пользователя (например, JWT)"]
},
{
  "question": "Какое преимущество Stateful перед Stateless?",
  "answers": [
    "Возможность мгновенной инвалидации сессии",
    "Более высокая производительность",
    "Не требует хранения данных",
    "Проще масштабируется"
  ],
  "correct": ["Возможность мгновенной инвалидации сессии"]
},
{
  "question": "Для чего нужен Refresh токен?",
  "answers": [
    "Для получения нового Access токена без повторного ввода логина/пароля",
    "Для доступа к API",
    "Для шифрования данных",
    "Для замены пароля"
  ],
  "correct": ["Для получения нового Access токена без повторного ввода логина/пароля"],
  "comment": "Refresh токены имеют больший срок жизни и хранятся безопасно."
},
{
  "question": "Что означает 'Bearer' в заголовке Authorization?",
  "answers": [
    "Тип токена, который передается 'как есть' без дополнительной криптографии",
    "Метод шифрования токена",
    "Название алгоритма подписи",
    "Способ хранения токена"
  ],
  "correct": ["Тип токена, который передается 'как есть' без дополнительной криптографии"]
},
{
  "question": "Как применяется хэширование при авторизации?",
  "answers": [
    "Для безопасного хранения паролей (например, bcrypt)",
    "Для создания Access токена",
    "Для шифрования JWT",
    "Для генерации сессионного ID"
  ],
  "correct": ["Для безопасного хранения паролей (например, bcrypt)"]
},
{
  "question": "Как декодировать JWT без проверки подписи?",
  "answers": [
    "Использовать base64url для Header и Payload",
    "Расшифровать алгоритмом AES",
    "Запустить jwt.decode() без секретного ключа",
    "JWT нельзя декодировать без ключа"
  ],
  "correct": ["Использовать base64url для Header и Payload"],
  "comment": "Подпись (Signature) проверить без ключа нельзя!"
},
{
  "question": "Что такое OAuth 2.0?",
  "answers": [
    "Протокол делегированного доступа к ресурсам",
    "Метод шифрования данных",
    "Система для хранения паролей",
    "Аналог JWT"
  ],
  "correct": ["Протокол делегированного доступа к ресурсам"]
},
{
  "question": "Чем OpenID Connect отличается от OAuth 2.0?",
  "answers": [
    "Добавляет слой аутентификации (ID токен)",
    "Использует только refresh токены",
    "Не поддерживает JWT",
    "Это одно и то же"
  ],
  "correct": ["Добавляет слой аутентификации (ID токен)"]
},
{
  "question": "Какая уязвимость возможна, если JWT использует алгоритм 'none'?",
  "answers": [
    "Токен можно подделать, отключив проверку подписи",
    "Токен станет нечитаемым",
    "Срок жизни токена обнулится",
    "Такой уязвимости не существует"
  ],
  "correct": ["Токен можно подделать, отключив проверку подписи"]
},
{
  "question": "Как безопасно хранить Refresh токен в SPA-приложении?",
  "answers": [
    "В HttpOnly cookie с Secure и SameSite=Strict",
    "В localStorage",
    "В window.name",
    "В URL-параметрах"
  ],
  "correct": ["В HttpOnly cookie с Secure и SameSite=Strict"]
},
{
  "question": "Какие типы grant types есть в OAuth 2.0?",
  "answers": [
    "Authorization Code, Implicit, Client Credentials, Password",
    "Только Login/Password",
    "JWT и Bearer",
    "OpenID и SAML"
  ],
  "correct": ["Authorization Code, Implicit, Client Credentials, Password"]
},
{
  "question": "Почему Stateless-архитектура лучше масштабируется?",
  "answers": [
    "Серверы не хранят состояние и не требуют синхронизации",
    "Не нужны балансировщики нагрузки",
    "Токены занимают меньше памяти",
    "Не требует HTTPS"
  ],
  "correct": ["Серверы не хранят состояние и не требуют синхронизации"]
},
{
  "question": "Зачем нужны OAuth и OpenID Connect?",
  "answers": [
    "OAuth — для делегированного доступа к ресурсам без передачи пароля, OpenID Connect — для аутентификации поверх OAuth",
    "OAuth — для хранения паролей, OpenID — для генерации токенов",
    "Это два конкурирующих стандарта аутентификации",
    "Только для мобильных приложений"
  ],
  "correct": ["OAuth — для делегированного доступа к ресурсам без передачи пароля, OpenID Connect — для аутентификации поверх OAuth"],
  "comment": "OAuth позволяет приложению получать ограниченный доступ к данным пользователя (например, через 'Войти через Google'), а OpenID добавляет стандартизированную аутентификацию (подтверждение личности)."
},
{
  "question": "Какую проблему решает OAuth?",
  "answers": [
    "Необходимость передавать логин/пароль третьим приложениям",
    "Отсутствие шифрования в HTTP",
    "Низкую скорость авторизации",
    "Ограничения JWT"
  ],
  "correct": ["Необходимость передавать логин/пароль третьим приложениям"],
  "comment": "OAuth предоставляет токены доступа вместо паролей, снижая риски утечки."
},
{
  "question": "Что добавляет OpenID Connect к OAuth 2.0?",
  "answers": [
    "ID-токен (JWT с данными пользователя) и стандартные endpoint'ы для аутентификации",
    "Новый алгоритм шифрования",
    "Поддержку только мобильных устройств",
    "Замену refresh-токенам"
  ],
  "correct": ["ID-токен (JWT с данными пользователя) и стандартные endpoint'ы для аутентификации"],
  "comment": "OpenID Connect = OAuth 2.0 + аутентификация + стандартизированные метаданные."
},
{
  "question": "В каком сценарии лучше использовать OAuth без OpenID?",
  "answers": [
    "Когда нужно только делегирование доступа к API (например, доступ к Google Диску)",
    "Для входа в мобильное приложение",
    "Для двухфакторной аутентификации",
    "Если нужны только почтовые адреса пользователей"
  ],
  "correct": ["Когда нужно только делегирование доступа к API (например, доступ к Google Диску)"],
  "comment": "OpenID избыточен, если не требуется подтверждение личности пользователя."
},
{
  "question": "Какой из этих токенов предоставляет OpenID Connect?",
  "answers": [
    "ID-токен (id_token)",
    "Только access_token",
    "Только refresh_token",
    "API-ключ"
  ],
  "correct": ["ID-токен (id_token)"],
  "comment": "ID-токен содержит claims о пользователе (email, имя и др.) в формате JWT."
},
{
  "question": "Почему OAuth/OpenID популярны для 'Войти через Facebook/Google'?",
  "answers": [
    "Пользователям не нужно создавать новые пароли, а разработчикам — хранить их",
    "Это единственный способ авторизации",
    "Они работают быстрее обычной аутентификации",
    "Не требуют HTTPS"
  ],
  "correct": ["Пользователям не нужно создавать новые пароли, а разработчикам — хранить их"],
  "comment": "Упрощает UX и снижает ответственность за хранение паролей."
}
];

</script>
</body>
</html>
